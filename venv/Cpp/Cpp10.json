{
    "Given a weighted, undirected and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree given below:": "/*\n#include<bits/stdc++.h>\nusing namespace std;\n# define INF 0x3f3f3f3f\n\n// iPair ==> Integer Pair\ntypedef pair<int, int> iPair;\n\n// This class represents a directed graph using\n// adjacency list representation\nclass Graph\n{\n\tint V; // No. of vertices\n\n\t// In a weighted graph, we need to store vertex\n\t// and weight pair for every edge\n\tlist< pair<int, int> > *adj;\n\npublic:\n\tGraph(int V); // Constructor\n\n\t// function to add an edge to graph\n\tvoid addEdge(int u, int v, int w);\n\n\t// Print MST using Prim's algorithm\n\tvoid primMST();\n};\n\n// Allocates memory for adjacency list\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list<iPair> [V];\n} */\n\nvoid Graph::addEdge(int u, int v, int w)\n{\n\t// Write your code here\n\tadj[u].push_back(make_pair(v,w));\n\tadj[v].push_back(make_pair(u,w));\n}\n",
    "Given a weighted, undirected and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree.": "// This class represents a directed graph using\n// adjacency list representation\nclass Graph\n{\n\tint V; // No. of vertices\n\n\t// In a weighted graph, we need to store vertex\n\t// and weight pair for every edge\n\tlist< pair<int, int> > *adj;\n\npublic:\n\tGraph(int V); // Constructor\n\n\t// function to add an edge to graph\n\tvoid addEdge(int u, int v, int w);\n\n\t// Print MST using Prim's algorithm\n\tvoid primMST();\n};\n\n// Allocates memory for adjacency list\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list<iPair> [V];\n}\nvoid Graph::addEdge(int u, int v, int w)\n{\n\tadj[u].push_back(make_pair(v, w));\n\tadj[v].push_back(make_pair(u, w));\n}\n",
    "Given a weighted, undirected and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree. Write the Prim's  function to find the MST edges.": "/*\n#include<bits/stdc++.h>\nusing namespace std;\n# define INF 0x3f3f3f3f\n\n// iPair ==> Integer Pair\ntypedef pair<int, int> iPair;\n\n// This class represents a directed graph using\n// adjacency list representation\nclass Graph\n{\n\tint V; // No. of vertices\n\n\t// In a weighted graph, we need to store vertex\n\t// and weight pair for every edge\n\tlist< pair<int, int> > *adj;\n\npublic:\n\tGraph(int V); // Constructor\n\n\t// function to add an edge to graph\n\tvoid addEdge(int u, int v, int w);\n\n\t// Print MST using Prim's algorithm\n\tvoid primMST();\n};\n\n// Allocates memory for adjacency list\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list<iPair> [V];\n} \nvoid Graph::addEdge(int u, int v, int w)\n{\n\tadj[u].push_back(make_pair(v, w));\n\tadj[v].push_back(make_pair(u, w));\n}\n\n*/\n\nint main()\n{\n\t// create the graph given in above figure\n\tint V;\n\tint edges,vertices,u,v,w;\n\t//cout<<\"Enter number of vertices and edges: \";\n    cin>>vertices>>edges;\n    V=vertices;\n\tGraph g(V);\n  \n    // Write your code here\n    for(int i=0;i<edges;i++)\n    {\n        cin>>u>>v>>w;\n        g.addEdge(u,v,w);\n    }\n    cout<<\"Prim's MST edges are: \";\n    g.primMST();\n  \n\treturn 0;\n}",
    "Given a weighted, undirected and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree. Fix the bugs in the given portion of code.": "class Graph\n{\n\tchar V; // No. of vertices\n\n\t// In a weighted graph, we need to store vertex\n\t// and weight pair for every edge\n\tlist< pair<int, int> > *adj;\n\npublic:\n\tGraph(int V); // Constructor\n\n\t// function to add an edge to graph\n\tvoid addEdge(int u, int v, int w);\n\n\t// Print MST using Prim's algorithm\n\tvoid primMST();\n};\n\n// Allocates memory for adjacency list\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list<iPair> [V];\n}\nvoid Graph::addEdge(int u, int v, int w)\n{\n\tadj[u].push_back(make_pair(v, w));\n\tadj[v].push_back(make_pair(u, w));\n}\n",
    "Given a weighted, undirected and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree. Correct the Prim's function to find the MST edges.": "/*\nclass Graph {\n\tvector<vector<int> > edgelist;\n\tint V;\n\npublic:\n\tGraph(int V) { this->V = V; }\n\t*/\nvoid addEdge(int x, int y, int w)\n{\n\t// Write your code here\n\tedgelist.push_back({ w, x, y });\n}",
    "Examples:": "/*\nclass Graph {\n\tvector<vector<int> > edgelist;\n\tint V;\n\npublic:\n\tGraph(int V) { this->V = V; }\n\t*/\nvoid addEdge(int x, int y, int w)\n{\n\t// Write your code here\n\tedgelist.push_back({w,x,y});\n\t\n}",
    "There are N cities numbered from 1 to N.": "class Graph {\n\tvector<vector<int> > edgelist;\n\tint V;\n\npublic:\n\tGraph(int V) {this->V = V; }\n\t\n\t\nvoid addEdge(int x,int  y,int  w)\n    {\n\t    edgelist.push_back({ w, x, y });\n    }\n",
    "Write a CPP unite function to find Kruskal's MST. ": "/*\nclass Graph {\n\tvector<vector<int> > edgelist;\n\tint V;\n\npublic:\n\tGraph(int V) { this->V = V; }\n\t*/\n\nint main()\n{\n\t int n, m;\n\t cin >> n >> m;\n\t Graph g(n);\n\t// Write your code here\n    for(int i=0;i<m;i++)\n    {\n        int x,y,w;\n        cin>>x>>y>>w;\n        g.addEdge(x,y,w);\n    }\n    g.kruskals_mst();\n\treturn 0;\n}",
    "You have recently started playing a brand new computer game called \"Mr. CM\". The game is about ruling a state, building infrastructures and developing it.": "int main()\n{\n\n\n\tint n, m;\n\t cin >> n >> m;\n\n\t Graph g(n);\n\tfor (int i = 0; i <= m; i++)\n\t{\n\t\t int x, y, w;\n\t\t cin >> x >> y >> w;\n\t\t g.addEdge(x,y, w);\n\t }\n\t \n\tg.kruskals_mst();\n\treturn 0;\n}\n",
    "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target.": "/*\n# define INF 0x3f3f3f3f\nlist< pair<int, int> > *adj;\n\nclass Graph\n{\n\tint V; // No. of vertices\n\n\npublic:\n\tGraph(int V); // Constructor\n\n\t// function to add an edge to graph\n\tvoid addEdge(int u, int v, int w);\n    list< pair<int, int> > *adj;\n\t// prints shortest path from s\n\tvoid shortestPath(int s);\n};\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list< pair<int, int> >[V];\n}\nvoid Graph::shortestPath(int src)\n{\n\n}*/\nvoid Graph::addEdge(int u, int v, int w)\n{\n\t//Write your code here\n\tadj[u].push_back(make_pair(v, w));\n\tadj[v].push_back(make_pair(u, w));\n}\n\n",
    "Write a CPP code to print shortest distances in the program to find Dijkstra's shortest path from A to all other vertices.": "void Graph::addEdge(int u, int v, int w)\n{\n\tadj[u].push_back(make_pair(v, w));\n\tadj[v].push_back(make_pair(u, w));\n}\n",
    "There are n cities connected by some number of flights. You are given values indicating [fromi, toi, pricei] means that there is a flight from city fromi to city toi with cost pricei.": "/*\n# define INF 0x3f3f3f3f\nlist< pair<int, int> > *adj;\n\nclass Graph\n{\n\tint V; // No. of vertices\n\n\npublic:\n\tGraph(int V); // Constructor\n\n\t// function to add an edge to graph\n\tvoid addEdge(int u, int v, int w);\n    list< pair<int, int> > *adj;\n\t// prints shortest path from s\n\tvoid shortestPath(int s);\n};\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list< pair<int, int> >[V];\n}\nvoid Graph::shortestPath(int src)\n{\n\n}*/\nvoid Graph::addEdge(int u, int v, int w)\n{\n\t\n\t//Write your code here\n\tadj[u].push_back(make_pair(v,w));\n\tadj[v].push_back(make_pair(u,w));\n}\n",
    "Write a CPP code to print shortest distances in the program to find Dijkstra's shortest path from a to all other vertices.": "// Prints shortest paths from src to all other vertices\nvoid Graph::shortestPath(int src)\n{\n\tset< pair<int, int> > setds;\n\tvector<int> dist(V, INF);\n\tsetds.insert(make_pair(0, src));\n\tdist[src] = 0;\n\twhile (!setds.empty())\n\t{\n\t\tpair<char, int> tmp = *(setds.begin());\n\t\tsetds.erase(setds.begin());\n\n\t\n\t\tint u = tmp.second;\n                \tlist< pair<int, int> >::iterator i;\n\t\tfor (i = adj[u].begin(); i != adj[u].end(); ++i)\n\t\t{\n\t\t\tint v = (*i).first;\n\t\t\tint weight = (*i).second;\n\t\t\tif (dist[v] > dist[u] + weight)\n\t\t\t{\n\t\t\t\tif (dist[v] != INF)\n\t\t\t\t\tsetds.erase(setds.find(make_pair(dist[v], v)));\n\t\t\t\tdist[v] = dist[u] + weight;\n\t\t\t\tsetds.insert(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\n\t// Print shortest distances stored in dist[]\n\tprintf(\"Vertex Distance from Source\\n\");\n\tfor (int i = 0; i < V; ++i)\n\t\tcout<<i<<\"  \"<<dist[i]<<endl;\n}\n",
    "Correct the given CPP code to print shortest distances in the program to find Dijkstra's shortest path from A to all other vertices.": "/*class Graph\n{\n\tint V; // No. of vertices\n\n\npublic:\n\tGraph(int V); // Constructor\n\n\t// function to add an edge to graph\n\tvoid addEdge(int u, int v, int w);\n    list< pair<int, int> > *adj;\n\t// prints shortest path from s\n\tvoid shortestPath(int s);\n};\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list< pair<int, int> >[V];\n}\n\nvoid Graph::addEdge(int u, int v, int w)\n{\n\tadj[u].push_back(make_pair(v, w));\n\tadj[v].push_back(make_pair(u, w));\n}\n\nvoid Graph::shortestPath(int src)\n{\n\tset< pair<int, int> > setds;\n\tvector<int> dist(V, INF);\n\tsetds.insert(make_pair(0, src));\n\tdist[src] = 0;\n\twhile (!setds.empty())\n\t{\n\t\tpair<int, int> tmp = *(setds.begin());\n\t\tsetds.erase(setds.begin());\n\n\t\n\t\tint u = tmp.second;\n                \tlist< pair<int, int> >::iterator i;\n\t\tfor (i = adj[u].begin(); i != adj[u].end(); ++i)\n\t\t{\n\t\t\tint v = (*i).first;\n\t\t\tint weight = (*i).second;\n\t\t\tif (dist[v] > dist[u] + weight)\n\t\t\t{\n\t\t\t\tif (dist[v] != INF)\n\t\t\t\t\tsetds.erase(setds.find(make_pair(dist[v], v)));\n\t\t\t\tdist[v] = dist[u] + weight;\n\t\t\t\tsetds.insert(make_pair(dist[v], v));\n\t\t\t}\n\t\t}\n\t}\n\n*/\n// Print shortest distances stored in dist[]\n\tprintf(\"Vertex Distance from Source\\n\");\n\tfor (int i = 0; i < V; ++i)\n\t\tcout<<char(i + 65)<<\" \"<<dist[i]<<\"\\n\";\n\t}\n\n",
    "Given a directed graph , where   is the set of nodes and A is the set of arcs. To each arc   corresponds a nonnegative cost  . The goal is to find a minimum cost Hamilton cycle in G, that is a closed tour passing through each node exactly once. Find the TSP solution using CPP function.": " /*class Graph \n{\n\n   public:\n    int** adjMatrix;\n  int numVertices;\n  // Initialize the matrix to zero\n  Graph(int numVertices) {\n    this->numVertices = numVertices;\n    adjMatrix = new int*[numVertices];\n    for (int i = 0; i < numVertices; i++) {\n      adjMatrix[i] = new int[numVertices];\n      for (int j = 0; j < numVertices; j++)\n        adjMatrix[i][j] = 0;\n    }\n  }\n\n  // Add edges\n  void addEdge(int i, int j,int w) {\n    adjMatrix[i][j] = w;\n    adjMatrix[j][i] = w;\n  }\n\n  // Remove edges\n  void removeEdge(int i, int j) {\n    adjMatrix[i][j] = 0;\n    adjMatrix[j][i] = 0;\n  }*/\n\n int TSP(int p) // implement traveling Salesman Problem. \n    {\n   vector<int> ver; //\n   for(int i = 0; i <V; i++)\n   {\n      if(i!=p)\n         ver.push_back(i);\n   }\n         int m_p = INT_MAX; // store minimum weight of a graph\n   do\n   {\n      //Write your from code here\n      \n      int cur_pth = 0;\n      int k = p;\n      for(int i=0;i<(int)ver.size();i++)\n      {\n         cur_pth += adjMatrix[k][ver[i]];\n         k = ver[i];\n      }\n      cur_pth += adjMatrix[k][p];\n      m_p = min(m_p, cur_pth);\n      \n      //Write your code upto here\n   }\n   while (next_permutation(ver.begin(), ver.end()));\n   return m_p;\n}\n",
    "In a computer network a link l, which interconnects two servers, is considered critical if there are atleast two servers s1 and s2 such that all network interconnection paths between s1 and ss2 pass through a link l. Removing a critical link generates two disjoint sub{networks such that any two servers of a sub network are interconnected. Write a CPP function to identify critical links/bridge(s) in a network.": " int TSP(int p) // implement traveling Salesman Problem. \n    {\n   vector<int> ver; //\n   for(int i = 0; i <V; i++)\n   {\n      if(i!=p)\n         ver.push_back(i);\n   }\n         int m_p = INT_MAX; // store minimum weight of a graph\n   do {\n      int cur_pth = 0;\n      int k = p;\n      for(int i=0;i<(int)ver.size();i++)\n      {\n         cur_pth += adjMatrix[k][ver[i]];\n         k = ver[i];\n      }\n      cur_pth += adjMatrix[k][p];\n      m_p = min(m_p, cur_pth); // to update the value of minimum weight\n   }\n   while (next_permutation(ver.begin(), ver.end()));\n   return m_p;\n}",
    "Write a CPP function to find the bipartite of a graph which is given by user.": "/*\n// A class that represents an undirected graph\nclass Graph\n{\n\tint V; // No. of vertices\n\tlist<int> *adj; // A dynamic array of adjacency lists\n\tvoid bridgeUtil(int v, bool visited[], int disc[], int low[],\n\t\t\t\t\tint parent[]);\npublic:\n\tGraph(int V); // Constructor\n\tvoid addEdge(int v, int w); // to add an edge to graph\n\tvoid bridge(); // prints all bridges\n};\n\nGraph::Graph(int V)\n{\n\tthis->V = V;\n\tadj = new list<int>[V];\n}\n\nvoid Graph::addEdge(int v, int w)\n{\n\tadj[v].push_back(w);\n\tadj[w].push_back(v); // Note: the graph is undirected\n}\n\n*/\n\nvoid Graph::bridge()\n{\n\t// Mark all the vertices as not visited\n\tbool *visited = new bool[V];\n\tint *disc = new int[V];\n\tint *low = new int[V];\n\tint *parent = new int[V];\n\t\n    //Write your code from here\n    for(int i=0;i<V;i++)\n    {\n        parent[i]=NIL;\n        visited[i]=false;\n    }\n    for(int i=0;i<V;i++)\n        if(visited[i]==false)\n            bridgeUtil(i,visited,disc,low,parent);\n    //Write your code upto here\n}",
    "A traveller needs to visit all cities from a list, where distances between all cities are known and visited once. What is the shortest possible routes that he visits each city exactly once and returns to the origin city?. Find the TSP solution using CPP function.": " /*class Graph \n{\n\n   public:\n    int** adjMatrix;\n  int numVertices;\n  // Initialize the matrix to zero\n  Graph(int numVertices) {\n    this->numVertices = numVertices;\n    adjMatrix = new int*[numVertices];\n    for (int i = 0; i < numVertices; i++) {\n      adjMatrix[i] = new int[numVertices];\n      for (int j = 0; j < numVertices; j++)\n        adjMatrix[i][j] = 0;\n    }\n  }\n\n  // Add edges\n  void addEdge(int i, int j,int w) {\n    adjMatrix[i][j] = w;\n    adjMatrix[j][i] = w;\n  }\n\n  // Remove edges\n  void removeEdge(int i, int j) {\n    adjMatrix[i][j] = 0;\n    adjMatrix[j][i] = 0;\n  }*/\n\n int TSP(int p) // implement traveling Salesman Problem. \n    {\n   vector<int> ver; //\n   \n   \n     //Write your code from here\n     for(int i=0;i<V;i++)\n     {\n         if(i!=p)\n            ver.push_back(i);\n     }\n     //Write your code upto here\n     \n         int m_p = INT_MAX; // store minimum weight of a graph\n  do {\n      int cur_pth = 0;\n      int k = p;\n      for(int i=0;i<(int)ver.size();i++)\n      {\n         cur_pth += adjMatrix[k][ver[i]];\n         k = ver[i];\n      }\n      cur_pth += adjMatrix[k][p];\n      m_p = min(m_p, cur_pth); // to update the value of minimum weight\n   }\n   while (next_permutation(ver.begin(), ver.end()));\n   return m_p;\n}\n",
    "Fix the bugs in a CPP function to find the bipartite of a graph which is given by user.": "/*\n#include <bits/stdc++.h>\nusing namespace std;\nclass Graph{\n    int numVertices;\n    list<int> *adjLists;\n    \n  public:\n    Graph(int V);\n    void addEdge(int src, int dest);\n};\n// Add edge\nvoid addEdge(vector<int> adj[], int s, int d) {\n  adj[s].push_back(d);\n  adj[d].push_back(s);\n}\n\n// Print the graph\nvoid printGraph(vector<int> adj[], int V) {\n  for (int d = 0; d < V; ++d) {\n    cout << \"\\n Vertex \"\n       << d << \":\";\n    for (auto x : adj[d])\n      cout << \"-> \" << x;\n    printf(\"\\n\");\n  }\n}\nvector<vector<int> > convert(vector<int> adj[],\n                             int V)\n{\n    // Initialize a matrix\n    vector<vector<int> > matrix(V,\n                                vector<int>(V, 0));\n \n    for (int i = 0; i < V; i++) {\n        for (auto j : adj[i])\n            matrix[i][j] = 1;\n    }\n    return matrix;\n}\n \n// Function to display adjacency matrix\nvoid printMatrix(vector<vector<int> > adj, int V)\n{\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            cout << adj[i][j] << \"   \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n \n\nint main() {\n  int V;\n  \n   int i,e,u,v;\n   cin>>V;\n  // Create a graph\n  vector<int> adj[V];\n  \n  cin>>e;\nfor(i=1;i<=e;i++)\n  {\n    cin>>u>>v;\n    addEdge(adj,u,v);\n  }\n\n  // Add edges\n  \n  ////printGraph(adj, V);\n  //cout << \"Adjacency List: \\n\";\n // vector<vector<int> > adjMatrix\n  //      = convert(adj, V);\n \n    // Display adjacency matrix\n   // cout << \"Adjacency Matrix: \\n\";\n   // printMatrix(adjMatrix, V);\n   bool ans = isBipartite(V, adj);\n    //returns 1 if bipartite graph is possible\n      if (ans)\n        cout << \"Yes bipartite graph\\n\";\n    //returns 0 if bipartite graph is not possible\n      else\n        cout << \"No not a bipartite graph\\n\";\n \n}*/\n/*\n#include <bits/stdc++.h>\nusing namespace std;\nclass Graph{\n    int numVertices;\n    list<int> *adjLists;\n    \n  public:\n    Graph(int V);\n    void addEdge(int src, int dest);\n};\n// Add edge\nvoid addEdge(vector<int> adj[], int s, int d) {\n  adj[s].push_back(d);\n  adj[d].push_back(s);\n}\n\n// Print the graph\nvoid printGraph(vector<int> adj[], int V) {\n  for (int d = 0; d < V; ++d) {\n    cout << \"\\n Vertex \"\n       << d << \":\";\n    for (auto x : adj[d])\n      cout << \"-> \" << x;\n    printf(\"\\n\");\n  }\n}\nvector<vector<int> > convert(vector<int> adj[],\n                             int V)\n{\n    // Initialize a matrix\n    vector<vector<int> > matrix(V,\n                                vector<int>(V, 0));\n \n    for (int i = 0; i < V; i++) {\n        for (auto j : adj[i])\n            matrix[i][j] = 1;\n    }\n    return matrix;\n}\n \n// Function to display adjacency matrix\nvoid printMatrix(vector<vector<int> > adj, int V)\n{\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            cout << adj[i][j] << \"   \";\n        }\n        cout << endl;\n    }\n    cout << endl;\n}\n \n\nint main() {\n  int V;\n  \n   int i,e,u,v;\n   cin>>V;\n  // Create a graph\n  vector<int> adj[V];\n  \n  cin>>e;\nfor(i=1;i<=e;i++)\n  {\n    cin>>u>>v;\n    addEdge(adj,u,v);\n  }\n\n  // Add edges\n  \n  ////printGraph(adj, V);\n  //cout << \"Adjacency List: \\n\";\n // vector<vector<int> > adjMatrix\n  //      = convert(adj, V);\n \n    // Display adjacency matrix\n   // cout << \"Adjacency Matrix: \\n\";\n   // printMatrix(adjMatrix, V);\n   bool ans = isBipartite(V, adj);\n    //returns 1 if bipartite graph is possible\n      if (ans)\n        cout << \"Yes bipartite graph\\n\";\n    //returns 0 if bipartite graph is not possible\n      else\n        cout << \"No not a bipartite graph\\n\";\n \n}*/\nbool isBipartite(int V, vector<int> adj[])\n{\n    // vector to store colour of vertex\n    // assigning all to -1 i.e. uncoloured\n    // colours are either 0 or 1\n      // for understanding take 0 as red and 1 as blue\n    vector<int> col(V, -1);\n \n    // queue for BFS storing {vertex , colour}\n    queue<pair<int, int> > q;\n   \n      //loop incase graph is not connected\n    for (int i = 0; i < V; i++) {\n       \n      //if not coloured\n        if (col[i] == -1) {\n           \n          //colouring with 0 i.e. red\n            q.push({ i, 0 });\n            col[i] = 0;\n           \n            while (!q.empty()) {\n                pair<int, int> p = q.front();\n                q.pop();\n               \n                  //current vertex\n                int v = p.first;\n                  //colour of current vertex\n                int c = p.second;\n                 \n                  //traversing vertexes connected to current vertex\n                for (int j : adj[v]) {\n                   \n                      //if already coloured with parent vertex color\n                      //then bipartite graph is not possible\n                    if (col[j] == c)\n                        return 0;\n                   \n                      //if uncoloured\n                    if (col[j] == -1) {\n                      //colouring with opposite color to that of parent\n                        col[j] = (c) ? 0 : 1;\n                        q.push({ j, col[j] });\n                    }\n                }\n            }\n        }\n    }\n    //if all vertexes are coloured such that\n      //no two connected vertex have same colours\n    return 1;\n}\n ",
    "Given, City1, City2, City3, City4 and distances between them as shown below. A salesman has to start from City 1, travel through all the cities and return to City1. There are various possible routes, but the problem is to find the shortest possible route. Fix the errors in  CPP function to find TSP solution.": "bool isBipartite(int V, vector<int> adj[])\n{\n    // vector to store colour of vertex\n    // assigning all to -1 i.e. uncoloured\n    // colours are either 0 or 1\n      // for understanding take 0 as red and 1 as blue\n    vector<int> col(V, -1);\n \n    // queue for BFS storing {vertex , colour}\n    queue<pair<int, int> > q;\n   \n      //loop incase graph is not connected\n    for (int i = 0; i < V; i++) {\n       \n      //if not coloured\n        if (col[i] == -1) {\n           \n          //colouring with 0 i.e. red\n            q.push({ i, 0 });\n            col[i] = 0;\n           \n            while (!q.empty()) {\n                pair<int, int> p = q.front();\n                q.pop();\n               \n                  //current vertex\n                int v = p.first;\n                  //colour of current vertex\n                int c = p.second;\n                 \n                  //traversing vertexes connected to current vertex\n                for (int j : adj[v]) {\n                   \n                      //if already coloured with parent vertex color\n                      //then bipartite graph is not possible\n                    if (col[j] == c)\n                        return 0;\n                   \n                      //if uncoloured\n                    if (col[j] == -1) {\n                      //colouring with opposite color to that of parent\n                        col[j] = (c) ? 0 : 1;\n                        q.push({ j, col[j] });\n                    }\n                }\n            }\n        }\n    }\n    //if all vertexes are coloured such that\n      //no two connected vertex have same colours\n    return 1;\n}\n ",
    "Give a connected graph,  find all the edges that are critical, in other words find the edges which when removed divide the graph. Fix the errors in the given CPP function to identify critical edges/bridge(s) in a network.": " /*class Graph \n{\n\n   public:\n    int** adjMatrix;\n  int numVertices;\n  // Initialize the matrix to zero\n  Graph(int numVertices) {\n    this->numVertices = numVertices;\n    adjMatrix = new int*[numVertices];\n    for (int i = 0; i < numVertices; i++) {\n      adjMatrix[i] = new int[numVertices];\n      for (int j = 0; j < numVertices; j++)\n        adjMatrix[i][j] = 0;\n    }\n  }\n\n  // Add edges\n  void addEdge(int i, int j,int w) {\n    adjMatrix[i][j] = w;\n    adjMatrix[j][i] = w;\n  }\n\n  // Remove edges\n  void removeEdge(int i, int j) {\n    adjMatrix[i][j] = 0;\n    adjMatrix[j][i] = 0;\n  }*/\n\n  int TSP(int p) // implement traveling Salesman Problem. \n    {\n   vector<int> ver; //\n   for(int i = 0; i <V; i++)\n   {\n      if(i!=p)\n         ver.push_back(i);\n   }\n         int m_p = INT_MAX; // store minimum weight of a graph\n   do {\n      int cur_pth = 0;\n      int k = p;\n      for(int i=0;i<(int)ver.size();i++)\n      {\n         cur_pth += adjMatrix[k][ver[i]];\n         k = ver[i];\n      }\n      cur_pth += adjMatrix[k][p];\n      m_p = min(m_p, cur_pth); // to update the value of minimum weight\n   }\n   while (next_permutation(ver.begin(), ver.end()));\n   return m_p;\n}"
}