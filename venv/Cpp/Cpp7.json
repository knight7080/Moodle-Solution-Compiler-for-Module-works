{
    "Complete the inorder function in your editor below, which has  parameter: a pointer to the root of a binary tree. It must print the values in the tree's inorder traversal as a single line of space-separated values.": "/*struct tree {\n    int info;\n    tree *Left, *Right;\n};\ntree* root;\nclass Binary_tree {\npublic:\n    Binary_tree();\n    void insert1(int);\n    tree* insert2(tree*, tree*);\n    void Delete(int);\n    void pretrav(tree*);\n    \n    void posttrav(tree*);\n    void search(int);\n    void intrav(tree*);\n};\n\nBinary_tree::Binary_tree()\n{\n    root = NULL;\n}\n*/\nvoid Binary_tree::intrav(tree* t = root)\n{\n    if (root == NULL) {\n        cout << \"Nothing to display\";\n    }\n    else if (t != NULL) {\n        intrav(t->Left);\n        cout << t->info << \" \";\n        intrav(t->Right);\n    }\n}",
    " Write a C++ Function to perform Preorder traversal of the below given tree": "/*struct node\n{\nchar data;\nstruct node *left;\nstruct node *right;\n};*/\n// Traverse Preorder\nvoid traversePreOrder(struct node *temp) \n{\n    if(temp!=NULL)\n    {\n        cout<<\" \"<<temp->data;\n        traversePreOrder(temp->left);\n        traversePreOrder(temp->right);\n    }\n}",
    " Write a C++ Function to perform Inorder traversal of the below given tree": "/*struct node\n{\nchar data;\nstruct node *left;\nstruct node *right;\n};\n*/\n\n// Traverse Inorder\nvoid traverseInOrder(struct node *temp) \n{\n    if(temp!=NULL)\n    {\n        traverseInOrder(temp->left);\n        cout<<\" \"<<temp->data;\n        traverseInOrder(temp->right);\n    }\n}",
    " Write a C++ Function to perform Postorder traversal of the below given tree": "/*struct node\n{\nchar data;\nstruct node *left;\nstruct node *right;\n};*/\n// Traverse Postorder\nvoid traversePostOrder(struct node *temp)\n{\n    if(temp!=NULL)\n    {\n        traversePostOrder(temp->left);\n        traversePostOrder(temp->right);\n        cout<<\" \"<<temp->data;\n    }\n}",
    " Write a C++ Functions to perform inorder,preorder and postorder traversal of the below given tree": "/*struct node\n{\nint data;\nstruct node *left;\nstruct node *right;\n};*/\n\n\n\n// Traverse Preorder\nvoid traversePreOrder(struct node *temp) \n{\n    if(temp!=NULL)\n    {\n        cout<<\" \"<<temp->data;\n        traversePreOrder(temp->left);\n        traversePreOrder(temp->right);\n    }\n}\n\n// Traverse Inorder\nvoid traverseInOrder(struct node *temp) \n{\n    if(temp!=NULL)\n    {\n        traverseInOrder(temp->left);\n        cout<<\" \"<<temp->data;\n        traverseInOrder(temp->right);\n    }\n}\n\n// Traverse Postorder\nvoid traversePostOrder(struct node *temp) \n{\n     if(temp!=NULL)\n    {\n        traversePostOrder(temp->left);\n        traversePostOrder(temp->right);\n        cout<<\" \"<<temp->data;\n    }\n}",
    "Write a C++ Function call to delete a node in a binary tree. Complete the deletion part of main function. ": "int main()\n{\n    Binary_tree bt;\n    int  x, n;\n    \n      \n            cin >> n;\n    while (n--) {\n            cin>>x;\n            bt.insert1(x);\n            }\n            \n            \n           \n            cin >> x;\n            bt.intrav();\n    \n    return 0;\n}",
    "Fix the bugs in a given C++ function to insert nodes in full binary tree.": "void insert_node(struct node *root, char n1, char n2, char lr)\n{\n    if(root == NULL)\n        return;\n    if(root->data ==n1)\n    {\n        switch(lr)\n        {\n        case 'l' :root -> left = newNode(n2);\n        break;\n        case 'r' : root -> right = newNode(n2);\n        break;\n        }\n    }\n    else\n    {\n        insert_node(root -> left, n1, n2, lr);\n        insert_node(root -> right, n1, n2, lr);\n    }\n}",
    "Fix the bugs in a given C++ Function to perform Postorder traversal of the below given tree": "void insert_node(struct node *root, int n1, int n2, char lr)\n{\nif(root == NULL)\nreturn;\nif(root -> data == n1)\n{\nswitch(lr)\n{\ncase 'l' :root -> left = newNode(n2);\nbreak;\ncase 'r' : root -> right = newNode(n2);\nbreak;\n}\n}\nelse\n{\ninsert_node(root -> left, n1, n2, lr);\ninsert_node(root -> right, n1, n2, lr);\n}\n}",
    " Fix the bugs in a given C++ Function to perform Preorder traversal of the below given tree": "void postorderTraversal(struct Node* node) {\n  if (node == NULL)\n    return;\n\n  postorderTraversal(node->left);\n  postorderTraversal(node->right);\n  cout << node->data << \"->\";\n}\n",
    "Fix the bugs in a given C++ function to perform Inorder traversal of the below given tree": "void postorderTraversal(struct Node* node) {\n  if (node == NULL)\n    return;\n\n  postorderTraversal(node->left);\n  postorderTraversal(node->right);\n  cout << node->data << \"->\";\n}\n\n",
    " Fix the bugs in a given C++ function to perform inorder,preorder and postorder traversal of the below given tree": "void preorderTraversal(struct Node* temp)\n{\n  if (temp == NULL)\n    return;\n\n  cout << temp->data << \"->\";\n  preorderTraversal(temp->left);\n  preorderTraversal(temp->right);\n}",
    "Write a C++ function to convert a binary tree into a binary search tree.": "/*struct Node1 {\n   int data;\n   struct Node1 *left, *right;\n};*/\n\n\nvoid convertBST(node *root,vector<int> InOrderArray,int& i)\n{\n    if(root)\n    {\n        convertBST(root->left,InOrderArray,i);\n        root->data=InOrderArray[i++];\n        convertBST(root->right,InOrderArray,i);\n    }\n}",
    "Write a C++Function to perform deletion in binary search tree. ": "// Inorder traversal function.\n// This gives data in sorted order.\nvoid BST ::Inorder(BST* root)\n{\n\tif (!root) {\n\t\treturn;\n\t}\n\tInorder(root->left);\n\tcout << root->data<<\" \";\n\tInorder(root->right);\n}\nvoid BST ::Preorder(BST* root)\n{\n\tif (!root) {\n\t\treturn;\n\t}\n\tcout << root->data<<\" \";\n\tPreorder(root->left);\n\tPreorder(root->right);\n}\n\n\nvoid BST ::Postorder(BST* root)\n{\n\tif (!root) {\n\t\treturn;\n\t}\n\tPostorder(root->left);\n\tPostorder(root->right);\n\tcout << root->data<<\" \";\n}",
    "Write a C++ Function that checks whether a tree is a Binary Search Tree or not.": "/*struct node\n{\nint data;\nstruct node *left;\nstruct node *right;\n};\n\nstruct node *newNode(int data)\n{\nstruct node *temp = (struct node *) malloc(sizeof(struct node));\ntemp -> data = data;\ntemp -> left = NULL;\ntemp -> right = NULL;\nreturn temp;\n};\n*/\nbool isBST(node *root)\n{\n   node *prev = NULL;\n   return isBSTUtil(root, prev);\n}\n",
    "Write a C++ function to find a largest value in a Binary Search Tree.": "int findMax(Node* root)\n{\n    // Base case\n    if (root == NULL)\n        return INT_MIN;\n \n    // Return maximum of 3 values:\n    // 1) Root's data 2) Max in Left Subtree\n    // 3) Max in right subtree\n    \n    // Write your code from here\n    int res = root->data;\n    int lres = findMax(root->left);\n    int rres = findMax(root->right);\n    if (lres > res)\n        res = lres;\n    if (rres > res)\n        res = rres;\n    // Write your code upto here\n    return res;\n}\n",
    "Write a C++ function to find the sum of k smallest elements in BST.": "/* Binary tree Node \nstruct Node\n{\n    int data;\n    Node* left, * right;\n};\n \n// utility function new Node of BST\nstruct Node *createNode(int data)\n{\n    Node * new_Node = new Node;\n    new_Node->left = NULL;\n    new_Node->right = NULL;\n    new_Node->data = data;\n    return new_Node;\n}\n*/\nint ksmallestElementSum(struct Node *root, int k)\n{\n    int count=0;\n    count=ksmallestElementSumRec(root, k, count); \n    return count;\n}",
    "The following numbers are inserted into an empty binary search tree in the given order:   8 12 10 16 25 20 15. ": "void convertBST(node *root,vector<int> InOrderArray,int& i){\n\tif(root){\n\t\tconvertBST(root->left,InOrderArray,i);\n\t\troot->data = InOrderArray[i++];\n\t\tconvertBST(root->right,InOrderArray,i);\n\t}\n}",
    "Binary Search Trees has the following properties:": "/*class BST {\n\tint data;\n\tBST *left, *right;\n\npublic:\n\t// Default constructor.\n\tBST();\n\n\t// Parameterized constructor.\n\tBST(int);\n\n\t// Insert function.\n\tBST* Insert(BST*, int);\n\n\t// Inorder traversal.\n\tvoid Inorder(BST*);\n\tvoid Preorder(BST*);\n\tvoid Postorder(BST*);\n};*/\n\n\n\nvoid BST ::Inorder(BST* root)\n{\n\t//Write your code here\n\tif(!root)\n\t    return;\n\tInorder(root->left);\n\tcout<<root->data<<\" \";\n\tInorder(root->right);\n}\nvoid BST ::Preorder(BST* root)\n{\n\t//Write your code here\n\tif(!root)\n\t    return;\n    cout<<root->data<<\" \";\n\tPreorder(root->left);\n\tPreorder(root->right);\n}\n\nvoid BST ::Postorder(BST* root)\n{\n\t//Write your code here\n\tif(!root)\n\t    return;\n\tPostorder(root->left);\n\tPostorder(root->right);\n\tcout<<root->data<<\" \";\n}",
    "Write a C++ function to check whether a tree is a Binary Search Tree or not and to traverse postorder  .": "/*struct node\n{\nint data;\nstruct node *left;\nstruct node *right;\n};\n\nstruct node *newNode(int data)\n{\nstruct node *temp = (struct node *) malloc(sizeof(struct node));\ntemp -> data = data;\ntemp -> left = NULL;\ntemp -> right = NULL;\nreturn temp;\n};*/\n\nbool isBSTUtil(struct node* root, node *&prev)\n{\n    // traverse the tree in inorder fashion and \n    // keep track of prev node\n    if (root)\n    {\n        //write your code here\n        if(!isBSTUtil(root->left,prev))\n            return false;\n        if(prev!=NULL && root->data<=prev->data)\n            return false;\n        prev = root;\n        return isBSTUtil(root->right,prev);\n    }\n    \n    return true;\n}",
    "The following numbers are inserted into an empty binary search tree in the given order:   2 4 6 1 -1. ": "/*class BST {\n\tint data;\n\tBST *left, *right;\n\npublic:\n\t// Default constructor.\n\tBST();\n\n\t// Parameterized constructor.\n\tBST(int);\n\n\t// Insert function.\n\tBST* Insert(BST*, int);\n\n\t// Inorder traversal.\n\tvoid Inorder(BST*);\n\tvoid Preorder(BST*);\n\tvoid Postorder(BST*);\n};*/\n\n\n\nvoid BST ::Inorder(BST* root)\n{\n\t//Write your code here\n    if(!root)\n        return;\n    Inorder(root->left);\n    cout<<root->data<<\" \";\n    Inorder(root->right);\n}\nvoid BST ::Preorder(BST* root)\n{\n\t//Write your code here\n\tif(!root)\n        return;\n    cout<<root->data<<\" \";\n    Preorder(root->left);\n    Preorder(root->right);\n}\nvoid BST ::Postorder(BST* root)\n{\n\t//Write your code here\n\tif(!root)\n        return;\n    Postorder(root->left);\n    Postorder(root->right);\n    cout<<root->data<<\" \";\n}",
    "Fix the errors to execute the function sucessfully. Given code is a C++ function to check whether a tree is a Binary Search Tree or not and to traverse postorder  .": "// Inorder traversal function.\n// This gives data in sorted order.\nvoid BST ::Inorder(BST* root)\n{\n\tif (!root) {\n\t\treturn;\n\t}\n\tInorder(root->left);\n\tcout << root->data<<\" \";\n\tInorder(root->right);\n}\nvoid BST ::Preorder(BST* root)\n{\n\tif (!root) {\n\t\treturn;\n\t}\n\tcout << root->data<<\" \";\n\tPreorder(root->left);\n\tPreorder(root->right);\n}\n\n\nvoid BST ::Postorder(BST* root)\n{\n\tif (!root) {\n\t\treturn;\n\t}\n\tPostorder(root->left);\n\tPostorder(root->right);\n\tcout << root->data<<\" \";\n}",
    "Write the default constructor definition of C++ Insert Function to perform insertion operation in binary search tree. ": "void traversePostOrder(struct node *temp)\n{\n  if (temp != NULL) \n  {\n    traversePostOrder(temp->left);\n    traversePostOrder(temp->right);\n    cout << \" \" << temp->data;\n  }\n}",
    "Correct the given C++ function to check whether a tree is a Binary Search Tree or not and to traverse inorder  .": "// Traverse Postorder\n\nvoid traversePostOrder(struct node *temp) {\n  if (temp != NULL) {\n    traversePostOrder(temp->left);\n    traversePostOrder(temp->right);\n    cout << \" \" << temp->data;\n  }\n}",
    "Fix the bugs in a given  C++ function to convert a binary tree into a binary search tree.": "BST::BST()\n    : data(0)\n    , left(NULL)\n    , right(NULL)\n{\n}",
    "Construct an Expression Tree from an infix expression for the given expression tree and evaluate the expression": "class node {\npublic:\n\tchar value;\n\tnode* left;\n\tnode* right;\n\tnode* next = NULL;\n\tnode(char c)\n\t{\n\t\tthis->value = c;\n\t\tleft = NULL;\n\t\tright = NULL;\n\t}\n\tnode()\n\t{\n\t\tleft = NULL;\n\t\tright = NULL;\n\t}\n\tfriend class Stack;\n\tfriend class expression_tree;\n};",
    "Construct an Expression Tree from an infix expression. Consider the below expression": "void buildTree(string eqn)\n{\n    for (int i = eqn.length() - 1; i >= 0; i--)\n        insert(eqn[i]);\n}",
    " Construct an expression tree from the given postfix expression. Generate the inorder and preorder traversal of the given expression tree below": "class node {\npublic:\n\tchar value;\n\tnode* left;\n\tnode* right;\n\tnode* next = NULL;\n\tnode(char c)\n\t{\n\t\tthis->value = c;\n\t\t//Write your code from here\n\t    left = NULL;\n\t    right = NULL;\n\t    //Write your code upto here\n\t}\n\tnode()\n\t{\n\t    //Write your code from here\n\t\tleft = NULL;\n\t    right = NULL;\n\t    //Write your code upto here\n\t}\n\tfriend class Stack;\n\tfriend class expression_tree;\n};",
    "Create a C++ code to perform LR rotation of an AVL Tree.": "Node* deleteNode(Node* root, int key)\n{\n     \n    // STEP 1: PERFORM STANDARD BST DELETE\n    if (root == NULL)\n        return root;\n \n    // If the key to be deleted is smaller\n    // than the root's key, then it lies\n    // in left subtree\n    if ( key < root->key )\n        root->left = deleteNode(root->left, key);\n \n    // If the key to be deleted is greater\n    // than the root's key, then it lies\n    // in right subtree\n    else if( key > root->key )\n        root->right = deleteNode(root->right, key);\n \n    // if key is same as root's key, then\n    // This is the node to be deleted\n    else\n    {\n        // node with only one child or no child\n        if( (root->left == NULL) ||\n            (root->right == NULL) )\n        {\n            Node *temp = root->left ?\n                         root->left :\n                         root->right;\n \n            // No child case\n            if (temp == NULL)\n            {\n                temp = root;\n                root = NULL;\n            }\n            else // One child case\n            *root = *temp; // Copy the contents of\n                           // the non-empty child\n            free(temp);\n        }\n        else\n        {\n            // node with two children: Get the inorder\n            // successor (smallest in the right subtree)\n            Node* temp = minValueNode(root->right);\n \n            // Copy the inorder successor's\n            // data to this node\n            root->key = temp->key;\n \n            // Delete the inorder successor\n            root->right = deleteNode(root->right,\n                                     temp->key);\n        }\n    }\n \n    // If the tree had only one node\n    // then return\n    if (root == NULL)\n    return root;\n \n    // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE\n    root->height = 1 + max(height(root->left),\n                           height(root->right));\n \n    // STEP 3: GET THE BALANCE FACTOR OF\n    // THIS NODE (to check whether this\n    // node became unbalanced)\n    int balance = getBalance(root);\n \n    // If this node becomes unbalanced,\n    // then there are 4 cases\n \n    // Left Left Case\n    if (balance > 1 &&\n        getBalance(root->left) >= 0)\n        return rightRotate(root);\n \n    // Left Right Case\n    \n    //Write your code here\n    \n \n    // Right Right Case\n    if (balance < -1 &&\n        getBalance(root->right) <= 0)\n        return leftRotate(root);\n \n    // Right Left Case\n    if (balance < -1 &&\n        getBalance(root->right) > 0)\n    {\n        root->right = rightRotate(root->right);\n        return leftRotate(root);\n    }\n \n    return root;\n}",
    "Write a C++ function to create an AVL Tree with the input elements. ": "Node* deleteNode(Node* root, int key)\n{\n     \n    // STEP 1: PERFORM STANDARD BST DELETE\n    if (root == NULL)\n        return root;\n \n    // If the key to be deleted is smaller\n    // than the root's key, then it lies\n    // in left subtree\n    if ( key < root->key )\n        root->left = deleteNode(root->left, key);\n \n    // If the key to be deleted is greater\n    // than the root's key, then it lies\n    // in right subtree\n    else if( key > root->key )\n        root->right = deleteNode(root->right, key);\n \n    // if key is same as root's key, then\n    // This is the node to be deleted\n    else\n    {\n        // node with only one child or no child\n        if( (root->left == NULL) ||\n            (root->right == NULL) )\n        {\n            Node *temp = root->left ?\n                         root->left :\n                         root->right;\n \n            // No child case\n            if (temp == NULL)\n            {\n                temp = root;\n                root = NULL;\n            }\n            else // One child case\n            *root = *temp; // Copy the contents of\n                           // the non-empty child\n            free(temp);\n        }\n        else\n        {\n            // node with two children: Get the inorder\n            // successor (smallest in the right subtree)\n            Node* temp = minValueNode(root->right);\n \n            // Copy the inorder successor's\n            // data to this node\n            root->key = temp->key;\n \n            // Delete the inorder successor\n            root->right = deleteNode(root->right,\n                                     temp->key);\n        }\n    }\n \n    // If the tree had only one node\n    // then return\n    if (root == NULL)\n    return root;\n \n    // STEP 2: UPDATE HEIGHT OF THE CURRENT NODE\n    root->height = 1 + max(height(root->left),\n                           height(root->right));\n \n    // STEP 3: GET THE BALANCE FACTOR OF\n    // THIS NODE (to check whether this\n    // node became unbalanced)\n    int balance = getBalance(root);\n \n    // If this node becomes unbalanced,\n    // then there are 4 cases\n \n    // Left Left Case\n    if (balance > 1 &&\n        getBalance(root->left) >= 0)\n        return rightRotate(root);\n \n    // Left Right Case\n    if (balance > 1 &&\n        getBalance(root->left) < 0)\n    {\n        root->left = leftRotate(root->left);\n        return rightRotate(root);\n    }\n \n    // Right Right Case\n    if (balance < -1 &&\n        getBalance(root->right) <= 0)\n        return leftRotate(root);\n \n    // Right Left Case\n    if (balance < -1 &&\n        getBalance(root->right) > 0)\n    {\n        root->right = rightRotate(root->right);\n        return leftRotate(root);\n    }\n \n    return root;\n}",
    "Write a C++ program to create an AVL Tree with the input elements.": "Node* insert(Node* node, int key)\n{\n\t\t/* 1. Perform the normal BST insertion */\n\tif (node == NULL)\n\t\treturn(newNode(key));\n\n\tif (key < node->key)\n\t\tnode->left = insert(node->left, key);\n\telse if (key > node->key)\n\t\tnode->right = insert(node->right, key);\n\telse // Equal keys are not allowed in BST\n\t\treturn node;\n\n\t/* 2. Update height of this ancestor node */\n\tnode->height = 1 + max(height(node->left),\n\t\t\t\t\t\theight(node->right));\n\n\t/* 3. Get the balance factor of this ancestor\n\t\tnode to check whether this node became\n\t\tunbalanced */\n\tint balance = getBalance(node);\n\n\t// If this node becomes unbalanced, then\n\t// there are 4 cases\n\n\t// Left Left Case\n\tif (balance > 1 && key < node->left->key)\n\t\treturn rightRotate(node);\n\n\t// Right Right Case\n\tif (balance < -1 && key > node->right->key)\n\t\treturn leftRotate(node);\n\n\t// Left Right Case\n\tif (balance > 1 && key > node->left->key)\n\t{\n\t\tnode->left = leftRotate(node->left);\n\t\treturn rightRotate(node);\n\t}\n\n\t// Right Left Case\n\tif (balance < -1 && key < node->right->key)\n\t{\n\t\tnode->right = rightRotate(node->right);\n\t\treturn leftRotate(node);\n\t}\n\n\t/* return the (unchanged) node pointer */\n\treturn node;\n}\nvoid inOrder(Node *root)\n{\n    if(root!=NULL)\n    {\n        inOrder(root->left);\n        cout<<root->key<<\" \";\n        inOrder(root->right);\n    }\n}",
    "Correct the given C++ code to create an AVL Tree with the input elements.": "Node* insert(Node* node, int key)\n{\n\t/* 1. Perform the normal BST insertion */\n\tif (node == NULL)\n\t\treturn(newNode(key));\n\n\tif (key < node->key)\n\t\tnode->left = insert(node->left, key);\n\telse if (key > node->key)\n\t\tnode->right = insert(node->right, key);\n\telse // Equal keys are not allowed in BST\n\t\treturn node;\n\n\t/* 2. Update height of this ancestor node */\n\tnode->height = 1 + max(height(node->left),\n\t\t\t\t\t\theight(node->right));\n\n\t/* 3. Get the balance factor of this ancestor\n\t\tnode to check whether this node became\n\t\tunbalanced */\n\tint balance = getBalance(node);\n\n\t// If this node becomes unbalanced, then\n\t// there are 4 cases\n\n\t// Left Left Case\n\tif (balance > 1 && key < node->left->key)\n\t\treturn rightRotate(node);\n\n\t// Right Right Case\n\tif (balance < -1 && key > node->right->key)\n\t\treturn leftRotate(node);\n\n\t// Left Right Case\n\tif (balance > 1 && key > node->left->key)\n\t{\n\t\tnode->left = leftRotate(node->left);\n\t\treturn rightRotate(node);\n\t}\n\n\t// Right Left Case\n\tif (balance < -1 && key < node->right->key)\n\t{\n\t\tnode->right = rightRotate(node->right);\n\t\treturn leftRotate(node);\n\t}\n\n\t/* return the (unchanged) node pointer */\n\treturn node;\n}",
    "Write a correct C++ code to perform RR rotation in an AVL Tree while inserting elements. ": "Node* insert(Node* node, int key)\n{\n\t/* 1. Perform the normal BST insertion */\n\tif (node == NULL)\n\t\treturn(newNode(key));\n\n\tif (key < node->key)\n\t\tnode->left = insert(node->left, key);\n\telse if (key > node->key)\n\t\tnode->right = insert(node->right, key);\n\telse // Equal keys are not allowed in BST\n\t\treturn node;\n\n\t/* 2. Update height of this ancestor node */\n\tnode->height = 1 + max(height(node->left),\n\t\t\t\t\t\theight(node->right));\n\n\t/* 3. Get the balance factor of this ancestor\n\t\tnode to check whether this node became\n\t\tunbalanced */\n\tint balance = getBalance(node);\n\n\t// If this node becomes unbalanced, then\n\t// there are 4 cases\n\n\t// Left Left Case\n\tif (balance > 1 && key < node->left->key)\n\t\treturn rightRotate(node);\n\n\t// Right Right Case\n\tif (balance < -1 && key > node->right->key)\n\t\treturn leftRotate(node);\n\n\t// Left Right Case\n\tif (balance > 1 && key > node->left->key)\n\t{\n\t\tnode->left = leftRotate(node->left);\n\t\treturn rightRotate(node);\n\t}\n\n\t// Right Left Case\n\tif (balance < -1 && key < node->right->key)\n\t{\n\t\tnode->right = rightRotate(node->right);\n\t\treturn leftRotate(node);\n\t}\n\n\t/* return the (unchanged) node pointer */\n\treturn node;\n}\n\n",
    "Correct a  C++ function to create an AVL Tree with the input elements. ": "Node* insert(Node* node, int key)\n{\n\t/* 1. Perform the normal BST insertion */\n\tif (node == NULL)\n\t\treturn(newNode(key));\n\n\tif (key < node->key)\n\t\tnode->left = insert(node->left, key);\n\telse if (key > node->key)\n\t\tnode->right = insert(node->right, key);\n\telse // Equal keys are not allowed in BST\n\t\treturn node;\n\n\t/* 2. Update height of this ancestor node */\n\tnode->height = 1 + max(height(node->left),\n\t\t\t\t\t\theight(node->right));\n\n\t/* 3. Get the balance factor of this ancestor\n\t\tnode to check whether this node became\n\t\tunbalanced */\n\tint balance = getBalance(node);\n\n\t// If this node becomes unbalanced, then\n\t// there are 4 cases\n\n\t// Left Left Case\n\tif (balance > 1 && key < node->left->key)\n\t\treturn rightRotate(node);\n\n\t// Right Right Case\n\tif (balance < -1 && key > node->right->key)\n\t\treturn leftRotate(node);\n\n\t// Left Right Case\n\tif (balance > 1 && key > node->left->key)\n\t{\n\t\tnode->left = leftRotate(node->left);\n\t\treturn rightRotate(node);\n\t}\n\n\t// Right Left Case\n\tif (balance < -1 && key < node->right->key)\n\t{\n\t\tnode->right = rightRotate(node->right);\n\t\treturn leftRotate(node);\n\t}\n\n\t/* return the (unchanged) node pointer */\n\treturn node;\n}"
}