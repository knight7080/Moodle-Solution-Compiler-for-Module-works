{
    "Write the search Module of B Tree in CPP": "void search(int val, int *pos, BTreeNode *myNode) {\n  if (!myNode) {\n    return;\n  }\n\n  if (val<myNode->val[1]) {\n    *pos = 0;\n  } else\n  {\n    for (*pos=myNode->count;(val<myNode->val[*pos] && *pos>1);(*pos)--);\n    if (val==myNode->val[*pos]) {\n      cout<<\"Element \"<<val<<\" found\";\n      return;\n    }\n  }\n  search(val, pos, myNode->link[*pos]);\n  return;\n}",
    "Write the setValue Module of B Tree in CPP.": "int setValue(int val, int *pval, BTreeNode *node, BTreeNode **child) {\n  int pos;\n  if (!node) {  //Leaf node or not\n    *pval = val;\n    *child= NULL;\n    return 1;\n  }\n\n  if (val<node->val[1]) {\n    pos = 0;\n  } else \n  {\n    for (pos=node->count;(val<node->val[pos] && pos>1);pos--);\n    if(val==node->val[pos])\n    {\n        cout<<\"Duplicates are not permitted\\n\";\n        return 0;\n    }\n  }\n  \n  if (setValue(val,pval,node->link[pos],child)) {\n    if (node->count < MAX) {\n     insertKey(*pval, pos, node, *child);\n    } else\n    {\n      splitNode(*pval, pval, pos, node, *child, child);\n      return 1;\n    }\n  }\n  return 0;\n}",
    "Write the findMin module of the B tree in CPP.": "void findMin(BTreeNode *myNode){\nBTreeNode *curr = myNode;\n      while(curr->link[0]!=NULL){\n       curr =curr->link[0] ;\n      }\n       cout<<endl<<\"Min=\"<<curr->val[1];\n}",
    "Write the splitNode Module of B Tree in CPP.": "void splitNode(int val, int *pval, int pos, BTreeNode *node, BTreeNode *child, BTreeNode **newNode)\n{\n    int median, j;\n\n  if (pos>MIN)\n    median = MIN + 1;\n  else\n    median = MIN;\n\n  *newNode = new BTreeNode;\n  j = median + 1;\n  while (j<=MAX) {\n    (*newNode)->val[j - median] = node->val[j];\n    (*newNode)->link[j - median] = node->link[j];\n    j++;\n  }\n  node->count = median; \n  (*newNode)->count = MAX - median; \n\n  if (pos<=MIN) {\n    insertKey(val, pos, node, child);\n  } else {\n    insertKey(val, pos - median, *newNode, child);\n  }\n  *pval = node->val[node->count];\n  (*newNode)->link[0] = node->link[node->count];\n node->count--;\n}",
    "Write the search module of B Tree and find out if the given char is present in the tree or not.": "void search(char val, int *pos, BTreeNode *myNode) {\n  if (!myNode) {\n    return;\n  }\n\n  if (val<myNode->val[1]) {\n    *pos = 0;\n  } else\n  {\n    for (*pos=myNode->count;(val<myNode->val[*pos] && *pos>1);(*pos)--);\n    if (val==myNode->val[*pos]) {\n      cout<<val<<\" is found\";\n      return;\n    }\n  }\n  search(val, pos, myNode->link[*pos]);\n  return;\n}",
    "Write the InsertInternal Module of the BPlus Tree in CPP": "void BPTree::insertInternal(int x, Node *cursor, Node *child) \n{\n      if (cursor->size<MAX) \n      {\n        int i = 0;\n        while (x>cursor->key[i] && i<cursor->size)\n          i++;\n        for (int j=cursor->size;j>i;j--) {\n          cursor->key[j] = cursor->key[j-1];\n        }\n        for (int j=cursor->size+1;j>1+1;j--) {\n          cursor->ptr[j] = cursor->ptr[j-1];\n        }\n        cursor->key[i] = x;\n        cursor->size++;\n        cursor->ptr[i + 1] = child;\n      }\n      else \n        {\n        Node *newInternal = new Node;\n        int virtualKey[MAX + 1];\n        Node *virtualPtr[MAX + 2];\n        for (int i = 0; i < MAX; i++) {\n          virtualKey[i]=cursor->key[i];\n        }\n        for (int i = 0;i<MAX+1; i++) {\n            virtualPtr[i] = cursor->ptr[i];\n        }\n        int i = 0, j;\n        while (x > virtualKey[i] && i < MAX)\n          i++;\n        for (int j = MAX + 1; j > i; j--) {\n            virtualKey[j]=virtualKey[j-1];\n        }\n        virtualKey[i] = x;\n        for (int j = MAX + 2; j&& + 1; j--) {\n          virtualPtr[j] = virtualPtr[j-1];\n        }\n        virtualPtr[i + 1] = child;\n        newInternal->IS_LEAF = false;\n        cursor->size = (MAX + 1) / 2;\n        newInternal->size = MAX-(MAX+1)/2;\n        for (i = 0, j = cursor->size + 1; i < newInternal->size; i++, j++) {\n          newInternal->key[i]=virtualKey[j];\n        }\n        for (i = 0, j = cursor->size + 1; i < newInternal->size + 1; i++, j++) {\n          newInternal->ptr[i]=virtualPtr[j];\n        }\n        if (cursor == root) {\n          Node *newRoot = new Node;\n          newRoot->key[0] = cursor->key[cursor->size];\n          newRoot->ptr[0] = cursor;\n          newRoot->ptr[1] = newInternal;\n          newRoot->IS_LEAF=false;\n          newRoot->size = 1;\n          root = newRoot;\n        } else\n        {\n          insertInternal(cursor->key[cursor->size], findParent(root, cursor), newInternal);\n        }\n    }\n}",
    "Write the Insert Module of the BPlus Tree in CPP": "void BPTree::insert(int x) {\n  if (root==NULL) {\n    root = new Node;\n    root->key[0] = x;\n    root->IS_LEAF = true;\n    root->size = 1;\n    } else \n    {\n    Node *cursor = root;\n    Node *parent;\n    while (cursor->IS_LEAF==false) \n    {\n      parent = cursor;\n      for (int i = 0;i<cursor->size ; i++) {\n        if (x<cursor->key[i]) {\n          cursor = cursor->ptr[i];\n          break;\n        }\n        if (i==cursor->size-1) {\n          cursor = cursor->ptr[i+1];\n          break;\n        }\n      }\n    }\n    if (cursor->size<MAX) \n    {\n      int i = 0;\n      while (x>cursor->key[i] && i<cursor->size)\n        i++;\n      for (int j=cursor->size;j>i;j--) {\n        cursor->key[j] = cursor->key[j - 1];\n      }\n      cursor->key[i] = x;\n      cursor->size++;\n      cursor->ptr[cursor->size] = cursor->ptr[cursor->size-1];\n      cursor->ptr[cursor->size-1] = NULL;\n    } else {\n      Node *newLeaf = new Node;\n      int virtualNode[MAX + 1];\n      for (int i=0;i<MAX;i++) {\n        virtualNode[i] = cursor->key[i];\n      }\n      int i = 0, j;\n      while (x > virtualNode[i] && i < MAX)\n        i++;\n      for (int j = MAX + 1; j > i; j--) {\n        virtualNode[j] = virtualNode[j - 1];\n      }\n      virtualNode[i] = x;\n      newLeaf->IS_LEAF = true;\n      cursor->size = (MAX+1)/2;\n      newLeaf->size = MAX + 1 - (MAX + 1) / 2;\n      cursor->ptr[cursor->size] = newLeaf;\n      newLeaf->ptr[newLeaf->size] = cursor->ptr[MAX];\n      cursor->ptr[MAX] = NULL;\n      for (i = 0; i < cursor->size; i++) {\n        cursor->key[i] = virtualNode[i];\n      }\n      for (i = 0, j = cursor->size;i<newLeaf->size; i++, j++) {\n        newLeaf->key[i] = virtualNode[j];\n      }\n      if (cursor == root) {\n        Node *newRoot = new Node;\n        newRoot->key[0] = newLeaf->key[0];\n        newRoot->ptr[0] = cursor;\n        newRoot->ptr[1] = newLeaf;\n        newRoot->IS_LEAF = false;\n        newRoot->size = 1;\n        root = newRoot;\n      } else {\n        insertInternal(newLeaf->key[0], parent, newLeaf);\n      }\n    }\n  }\n}",
    "Write the Search Module of the BPlus Tree in CPP": "void BPTree::search(int x) {\n  if (root==NULL) {\n    cout << \"Tree is empty\\n\";\n  } else {\n    Node *cursor = root;\n    while ( cursor->IS_LEAF== false) {\n      for (int i = 0; i < cursor->size; i++) {\n        if (x < cursor->key[i]) {\n          cursor = cursor->ptr[i];\n          break;\n        }\n        if (i==cursor->size-1) {\n          cursor = cursor->ptr[i+1];\n          break;\n        }\n      }\n    }\n    for (int i = 0; i < cursor->size; i++) {\n      if (cursor->key[i]==x) {\n        cout << \"Found\\n\";\n        return;\n      }\n    }\n    cout << \"Not found\\n\";\n  }\n}",
    "Write the findParent Module of the BPlus Tree in CPP": "Node *BPTree::findParent(Node *cursor, Node *child) {\n  Node *parent;\n  if (cursor->IS_LEAF || (cursor->ptr[0])->IS_LEAF) {\n    return NULL;\n  }\n  for (int i = 0; i < cursor->size + 1; i++) {\n    if (cursor->ptr[i]==child) {\n      parent = cursor;\n      return parent;\n    } else {\n      parent = findParent(cursor->ptr[i], child);\n      if (parent!=NULL)\n        return parent;\n    }\n  }\n  return parent;\n}",
    "Write the Right rotate module of the red black tree in CPP.": "void rightrotate(node* temp)\n{\n    node* left = temp->l;\n    temp->l = left->r;\n    if (temp->l)\n        temp->l->p = temp;\n    left->p = temp->p;\n    if (!temp->p)\n        root = left;\n    else if (temp == temp->p->l)\n        temp->p->l = left;\n    else\n        temp->p->r = left;\n    left->r = temp;\n    temp->p = left;\n}",
    "Write the Traversal module of the red black tree in CPP.": "void inorder(node* root)\n{\n    if (root==NULL)\n        return;\n    inorder(root->l);\n    cout<<\"Data=\"<<root->d<<\" \"<<\"Color=\"<< root->c<<endl;\n    inorder(root->r);\n}",
    "Write the fixup module of the red black tree in CPP.": "void fixup(node* root, node* pt)\n{\n    node* parent_pt = NULL;\n    node* grand_parent_pt = NULL;\n \n    while ((pt!=root)&&(pt->c!=0)&&(pt->p->c==1))\n    {\n        parent_pt = pt->p;\n        grand_parent_pt = pt->p->p;\n \n        //  Case : A Parent of pt is left child of Grand-parent of pt \n        if (parent_pt == grand_parent_pt->l)\n        {\n            \n            node* uncle_pt=grand_parent_pt->r;\n            // Case : 1 The uncle of pt is also red Only Recoloring required \n            \n            if (uncle_pt!=NULL && uncle_pt->c==1)\n            {\n                grand_parent_pt->c = 1;\n                parent_pt->c = 0;\n                uncle_pt->c = 0;\n                pt = grand_parent_pt;\n            }\n \n            else {\n \n                // Case : 2 pt is right child of its parent Left-rotation required \n                if (pt==parent_pt->r) \n                {\n                    leftrotate(parent_pt);\n                    pt = parent_pt;\n                    parent_pt = pt->p;\n                }\n \n        //Case : 3 pt is left child of its parent Right-rotation required \n                rightrotate(grand_parent_pt);\n                int t = parent_pt->c;\n                parent_pt->c = grand_parent_pt->c;\n                grand_parent_pt->c = t;\n                pt = parent_pt;\n            }\n        }\n \n        // Case : BParent of pt is right child of Grand-parent of pt \n        else {\n            node* uncle_pt = grand_parent_pt->l;\n \n        //  Case : 1 The uncle of pt is also red Only Recoloring required \n            if ((uncle_pt!=NULL)&&(uncle_pt->c==1))\n            {\n                grand_parent_pt->c = 1;\n                parent_pt->c = 0;\n                uncle_pt->c = 0;\n                pt = grand_parent_pt;\n            }\n            else \n            {\n       // Case : 2 pt is left child of its parent Right-rotation required \n                if ( pt==parent_pt->l)\n                {\n                    rightrotate(parent_pt);\n                    pt=parent_pt;\n                    parent_pt = pt->p;\n                }\n \n        // Case : 3 pt is right child of its parent Left-rotation required \n                leftrotate(grand_parent_pt);\n                int t = parent_pt->c;\n                parent_pt->c = grand_parent_pt->c;\n                grand_parent_pt->c=t;\n                pt = parent_pt;\n            }\n        }\n    }\n \n    root->c = 0;\n}",
    "Write the Red Black Tree construction module in CPP.": "node* bst(node* trav, node* temp)\n{\n    // If the tree is empty,\n    // return a new node\n    if (trav==NULL)\n        return temp;\n \n    // Otherwise recur down the tree\n    if (temp->d<trav->d)\n    {\n        trav->l = bst(trav->l, temp);\n        trav->l->p = trav;\n    }\n    else if (temp->d>trav->d)\n    {\n        trav->r = bst(trav->r, temp);\n        trav->r->p=trav;\n    }\n \n    // Return the (unchanged) node pointer\n    return trav;\n}",
    "Write the Left rotate module of the red black tree in CPP.": "void leftrotate(node* temp)\n{\n    node* right = temp->r;\n    temp->r = right->l;\n    if (temp->r)\n        temp->r->p = temp;\n    right->p = temp->p;\n    if (!temp->p)\n        root = right;\n    else if (temp==temp->p->l)\n        temp->p->l = right;\n    else\n        temp->p->r =right ;\n    right->l = temp;\n    temp->p = right;\n}\n",
    "Write the preOrder Traversal module of splay tree in CPP.": "void preOrder(struct node *root)\n{\n    if (root!=NULL)\n    {\n        cout<<root->key<<\" \";\n        preOrder(root->left);\n        preOrder(root->right);\n    }\n}\n",
    "Write the right rotate module of splay tree in CPP.": "node *rightRotate(struct node *x)    // x pointer to the parent, y pointer to the node(child)\n{\n    node *y =x->left ;\n    x->left = y->right;\n    y->right = x;\n    return y;\n}",
    "Write the Splay/BST construction module of splay tree in CPP.": "node *BST(node *root, int key){\n    if(root==NULL){\n        node *newnode = new node;\n        newnode->key = key;\n        newnode->left = NULL;\n        newnode->right = NULL;\n        \n        return newnode;\n    }\n    \n    else{\n        if(root->key>key){\n            root->left = BST(root->left, key);\n        }\n        else{\n            root->right = BST(root->right, key);\n        }\n    }\n    \n    return root;\n}\n\n",
    "Write the left rotate module of splay tree in CPP.": "node *leftRotate(struct node *x)     // x pointer to the parent, y pointer to the node(child)\n{\n    node *y =x->right ;\n    x->right = y->left;\n    y->left = x;\n    return y;\n}",
    "Write the splay module of the splay tree in CPP": "node *splay(node *root, int key)\n{\n    if(root->key==key)\n        return root;\n    if(root->key>key)\n    {\n        if(root->left==NULL)\n            return root;\n        if(root->left->key>key)\n        {\n            root->left->left=splay(root->left->left,key);\n            root=rightRotate(root);\n        }\n        else if(root->left->key<key)\n        {\n            root->left->right=splay(root->left->right,key);\n            if(root->left->right!=NULL)\n                root->left=leftRotate(root->left);\n        }\n        return (root->left==NULL)?root:rightRotate(root);\n    }\n    else\n    {\n        if(root->right==NULL)\n            return root;\n        if(root->right->key>key)\n        {\n            root->right->left=splay(root->right->left,key);\n            if(root->right->left!=NULL)\n                root->right=rightRotate(root->right);\n        }\n        else if(root->right->key<key)\n        {\n            root->right->right=splay(root->right->right,key);\n            root=leftRotate(root);\n        }\n        return (root->right==NULL)?root:leftRotate(root);\n    }\n} "
}