{
    "For example:": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector< vector <int>> g;\nvector<bool> v;\n\n// Undirected graph\nvoid addEdge(int a, int b)\n{\n\tg[a].push_back(b);\n\tg[b].push_back(a);\n}\n\nvoid dfsVisit(int u)\n{\n\tv[u] = true;\n\tcout << u << \" \";\n\n\tfor(auto i = g[u].begin(); i != g[u].end(); i++)\n\t{\n\t\tif(!v[*i])\n\t\t\tdfsVisit(*i);\n\t}\n}\n\nvoid dfs(int n)\n{\n\tfor(int u = 0; u < n; u++)\n\t{\n\t\tif(!v[u])\n\t\t\tdfsVisit(u);\n\t}\n}\n\nint main()\n{\n\tint n, e;\n\tcin >> n >> e;\n\n\tv.assign(n, false);\n\tg.assign(n, vector<int>());\n\n\tint a, b;\n\tfor(int i = 0; i < e; i++)\n\t{\n\t\tcin >> a >> b;\n\t\taddEdge(a,b);\n\t}\n\tdfs(n);\n}",
    "Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct pair \n{\n\tint a, b;\n\tpair(int a, int b) : a(a), b(b) {}\n\t\n\tstd::ostream &print(std::ostream &out) const \n\t{\n\t\treturn (out << \"(\" << a << \", \" << b << \")\");\n\t}\n};\n\nstd::ostream &operator<<(std::ostream &out, const pair &p) \n{ \n    return p.print(out); \n    \n}\n\nstruct topological_pair_comparator \n{\n\tbool operator()(const pair &p, const pair &q) const \n\t{ \n\t    return p.a<q.a && p.b<q.b; \n\t    \n\t}\n} tpc;\n\nstd::vector<pair> pairs = \n{\n\n\tpair(1,1),\n\tpair(1,2),\n    pair(2,1),\n    pair(3,1),\n\tpair(1,3),\n\tpair(2,2),\n\tpair(4,0),\n    pair(5,5),\n};\n\nint main() {\n\tstd::sort(pairs.begin(), pairs.end(), tpc);\n\tfor(const pair &p : pairs) std::cout << p << \" \";\n\tstd::cout << std::endl;\n\treturn 0;\n}"
}