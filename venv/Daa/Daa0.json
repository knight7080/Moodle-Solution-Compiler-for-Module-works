{
    "Write a Program for Implementing merge sort using python recursion.": "def merge_sort(inp_arr):\n    if len(inp_arr) < 2:               \n        return inp_arr\n    result = []                  \n    mid = int(len(inp_arr) / 2)  \n     \n    y = merge_sort(inp_arr[:mid])       \n    z = merge_sort(inp_arr[mid:])       \n    i = 0\n    j = 0\n    while i < len(y) and j < len(z):\n        if y[i] > z[j]:\n            result.append(z[j])\n            j += 1\n        else:\n            result.append(y[i])\n            i += 1\n    result += y[i:]             \n    result += z[j:]             \n    return result \n    \ninp_arr=[]\nn=int(input())\nfor i in range(n):\n    inp_arr.append(int(input()))\nprint(\"Input Array:\\n\")\nprint(inp_arr)\nprint(\"Sorted Array:\\n\")\nprint(merge_sort(inp_arr))",
    "You are the king of Pensville where you have \n2\nN\n workers.\nAll workers will be grouped in association of size 2,so a total of N associations have to be formed.\nThe building speed of the \ni\nt\nh\n worker is \nA\ni\n.\nTo make an association, you pick up 2 workers. Let the minimum building speed between both workers be x, then the association has the resultant building speed x.\nYou have to print the maximum value possible of the sum of building speeds of N associations if you make the associations optimally.": "n=int(input())\na=list(map(int,input().split()))\na.sort()\nt=0\nfor i in range(2*n-2,-1,-2):\n    t+=a[i]\nprint(t)",
    "Write a python program to implement merge sort using iterative approach on the given list of  float values.": "def Merge_Sort(S):\n    if len(S)<2:\n        return S\n    result=[]\n    mid=int(len(S)/2)\n    y=Merge_Sort(S[:mid])\n    z=Merge_Sort(S[mid:])\n    i=0\n    j=0\n    if i<len(y) and j<len(z):\n        if y[i]<z[i]:\n            result.append(y[i])\n            i=i+1\n        else:\n            result.append(z[j])\n            j=j+1\n    result+=y[i:]\n    result+=z[j:]\n    result.sort()\n    return result\nn=int(input())\nS=[]\nfor i in range(0,n):\n    S.append(float(input()))\nprint(\"The Original array is: \",S)\nprint(\"Array after sorting is: \",Merge_Sort(S))",
    "Write a Python Program to find minimum number of swaps required to sort an float array given by the user.": "def minSwaps(arr):\n    n = len(arr)\n    arrpos = [*enumerate(arr)]\n    arrpos.sort(key = lambda it : it[1])\n    vis = {k : False for k in range(n)}\n    ans = 0\n    for i in range(n):\n        if vis[i] or arrpos[i][0] == i:\n            continue\n        cycle_size = 0\n        j = i\n         \n        while not vis[j]:\n            vis[j] = True\n            j = arrpos[j][0]\n            cycle_size += 1\n        if cycle_size > 0:\n            ans += (cycle_size - 1)\n    return ans\n\narr=[]    \nn=int(input())\nfor i in range(n):\n    arr.append(float(input()))\nprint(minSwaps(arr))",
    "Write a recursive python function to perform merge sort on the unsorted list of float values.": "def mergesort(li):\n    if len(li) < 2:               \n        return li\n    result = []                  \n    mid = int(len(li) / 2)  \n     \n    y = mergesort(li[:mid])       \n    z = mergesort(li[mid:])       \n    i = 0\n    j = 0\n    while i < len(y) and j < len(z):\n        if y[i] > z[j]:\n            result.append(z[j])\n            j += 1\n        else:\n            result.append(y[i])\n            i += 1\n    result += y[i:]             \n    result += z[j:]             \n    return result \n    \nli=[]\nn=int(input())\nfor i in range(n):\n    li.append(float(input()))\nprint(mergesort(li))",
    "Write a python program for the implementation of merge sort on the given list of values.": "def mergesort(li):\n    if len(li) < 2:               \n        return li\n    result = []                  \n    mid = int(len(li) / 2)  \n     \n    y = mergesort(li[:mid])       \n    z = mergesort(li[mid:])       \n    i = 0\n    j = 0\n    while i < len(y) and j < len(z):\n        if y[i] > z[j]:\n            result.append(z[j])\n            j += 1\n        else:\n            result.append(y[i])\n            i += 1\n    result += y[i:]             \n    result += z[j:]             \n    return result \n    \nli=[]\nn=int(input())\nfor i in range(n):\n    li.append(int(input()))\nprint(\"Given array is\")\nfor i in li:\n    print(i,end=' ')\n    \nli=mergesort(li)\n\nprint(\"\\nSorted array is\")\nfor i in li:\n    print(i,end=' ')",
    "Write a python program to sort the first half of the list using merge sort": "def merge(arr, l, m, r):\n    #Add Your Code here#######################\n    n1 = m - l + 1\n    n2 = r - m\n    L = [0] * (n1)\n    R = [0] * (n2)\n    for i in range(0, n1):\n        L[i] = arr[l + i]\n \n    for j in range(0, n2):\n        R[j] = arr[m + 1 + j]\n \n    i = 0     \n    j = 0     \n    k = l     \n \n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n \n    # Copy the remaining elements of L[], if there\n    # are any\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n \n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\ndef mergeSort(arr, l, r):\n    if l < r:\n        m = l+(r-l)//2\n        mergeSort(arr, m+1, r)\n        merge(arr, l, m, r)\n\narr =[]               \nn =int(input())\nfor i in range(n):\n    arr.append(int(input()))\nprint(\"Given array is\")\nfor i in range(n):\n    print(\"%d\" % arr[i],end=\" \")\n \nmergeSort(arr, 0, n-1)\nprint(\"\\n\\nSorted array is\")\nfor i in range(n):\n    print(\"%d\" % arr[i],end=\" \")",
    "Write a python program to sort the first half of the list using merge sort with float values.": "def merge(arr, l, m, r):\n    #Add Your Code here#######################\n    n1 = m - l + 1\n    n2 = r - m\n    L = [0] * (n1)\n    R = [0] * (n2)\n    for i in range(0, n1):\n        L[i] = arr[l + i]\n \n    for j in range(0, n2):\n        R[j] = arr[m + 1 + j]\n \n    i = 0     \n    j = 0     \n    k = l     \n \n    while i < n1 and j < n2:\n        if L[i] <= R[j]:\n            arr[k] = L[i]\n            i += 1\n        else:\n            arr[k] = R[j]\n            j += 1\n        k += 1\n \n    # Copy the remaining elements of L[], if there\n    # are any\n    while i < n1:\n        arr[k] = L[i]\n        i += 1\n        k += 1\n \n    while j < n2:\n        arr[k] = R[j]\n        j += 1\n        k += 1\n\ndef mergeSort(arr, l, r):\n    if l < r:\n        m = l+(r-l)//2\n        mergeSort(arr, m+1, r)\n        merge(arr, l, m, r)\n\narr =[]               \nn =int(input())\nfor i in range(n):\n    arr.append(float(input()))\nprint(\"Given array is\")\nfor i in range(n):\n    print(\"%.1f\" % arr[i],end=\" \")\n \nmergeSort(arr, 0, n-1)\nprint(\"\\n\\nSorted array is\")\nfor i in range(n):\n    print(\"%.1f\" % arr[i],end=\" \")",
    "Write a python program to implement quick sort on the given values and print the sorted list and pivot value of each iteration.": "def quick_sort(alist, start, end):\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quick_sort(alist, start, p)\n        quick_sort(alist, p + 1, end)\n \ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n    print(\"pivot: \",pivot)\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n \n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\nalist = []\nn=int(input())\nfor i in range(n):\n    alist.append(int(input()))\nprint('Input List\\n', alist)\n\nquick_sort(alist, 0, len(alist))\nprint('Sorted List\\n', alist)",
    "Write a python to implement Quick sort using the first element as pivot value": "def quick_sort(alist, start, end):\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quick_sort(alist, start, p)\n        quick_sort(alist, p + 1, end)\n \ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n    print(\"Pivot: \",pivot)\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n \n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\nalist = []\nn=int(input())\nfor i in range(n):\n    alist.append(int(input()))\n\nquick_sort(alist, 0, len(alist))\nprint(\"Sorted array:\", alist)",
    "Write a Python program to sort unsorted numbers using Multi-key quicksort": "def quick_sort_3partition(alist, start, end):\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quick_sort_3partition(alist, start, p)\n        quick_sort_3partition(alist, p + 1, end)\n \ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n    #print(\"Pivot: \",pivot)\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n \n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\nnums = []\nn=int(input())\nfor i in range(n):\n    nums.append(int(input()))\nprint(\"Original list:\")\nprint(nums)\nquick_sort_3partition(nums, 0, n)\nprint(\"After applying Random Pivot Quick Sort the said list becomes:\")\nprint(nums)",
    "Write a python program to implement quick sort using tha last element as pivot on the list of float values.": "def quickSort(alist, start, end):\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quickSort(alist, start, p)\n        quickSort(alist, p + 1, end)\n \ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n    #print(\"Pivot: \",pivot)\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n \n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\narr = []\nn=int(input())\nfor i in range(n):\n    arr.append(float(input()))\nquickSort(arr, 0, n)\nprint(\"Sorted array is:\")\nfor i in arr:\n    print(i)",
    "Write a python program to implement the quick sort using recursion on the given list of float values.": "def part(arr,l,r):\n    pi=arr[r]\n    i=l-1\n    for j in range(l,r):\n        if arr[j]<=pi:\n            i=i+1\n            arr[i],arr[j]=arr[j],arr[i]\n        \n    arr[i+1],arr[r]=arr[r],arr[i+1]\n    return i+1\ndef quickSort(arr,l,r):\n    if l<r:\n        p=part(arr,l,r)\n        print(\"pivot: \",arr[p])\n        quickSort(arr,l,p-1)\n        quickSort(arr,p+1,r)\n    return arr\n    \narr=list()\nn=int(input())\nfor i in range(0,n):\n    ele=float(input())\n    arr.append(ele) \nprint(quickSort(arr,0,n-1))",
    "Write a Python program to sort unsorted numbers using Random Pivot Quick Sort. Picks the random index as the pivot": "def quick_sort_random(alist, start, end):\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quick_sort_random(alist, start, p)\n        quick_sort_random(alist, p + 1, end)\n \ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n    #print(\"Pivot: \",pivot)\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n \n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\nnums = []\nn=int(input())\nfor i in range(n):\n    nums.append(int(input()))\nprint(\"Original list:\")\nprint(nums)\nquick_sort_random(nums, 0, n)\nprint(\"After applying Random Pivot Quick Sort the said list becomes:\")\nprint(nums)",
    "Write a python program to implement quick sort using last element as pivot on the given list of integers.": "def quickSort(alist, start, end):\n    if end - start > 1:\n        p = partition(alist, start, end)\n        quickSort(alist, start, p)\n        quickSort(alist, p + 1, end)\n \ndef partition(alist, start, end):\n    pivot = alist[start]\n    i = start + 1\n    j = end - 1\n    #print(\"Pivot: \",pivot)\n    while True:\n        while (i <= j and alist[i] <= pivot):\n            i = i + 1\n        while (i <= j and alist[j] >= pivot):\n            j = j - 1\n \n        if i <= j:\n            alist[i], alist[j] = alist[j], alist[i]\n        else:\n            alist[start], alist[j] = alist[j], alist[start]\n            return j\n\narr = []\nn=int(input())\nfor i in range(n):\n    arr.append(int(input()))\nquickSort(arr, 0, n)\nprint(\"Sorted array is:\")\nfor i in arr:\n    print(i)",
    "Write a python program to implement quick sort on the given float  array values.": "def qsort(L):\n    if L==[]:\n        return[]\n    pivot=L[0:1]\n    left=qsort([x for x in L[1:]if x<L[0]])\n    right=qsort([x for x in L[1:]if x>=L[0]])\n    print(\"left: \",left)\n    print(\"right: \",right)\n    return left+pivot+right\nlist1=[]\nn=int(input())\nfor i in range(n):\n    list1.append(float(input()))\nprint(qsort(list1))",
    "Write a python program to implement the quick sort using recursion.": "def part(arr,l,r):\n    pi=arr[r]\n    i=l-1\n    for j in range(l,r):\n        if arr[j]<=pi:\n            i=i+1\n            arr[i],arr[j]=arr[j],arr[i]\n        \n    arr[i+1],arr[r]=arr[r],arr[i+1]\n    return i+1\ndef quickSort(arr,l,r):\n    if l<r:\n        p=part(arr,l,r)\n        print(\"pivot: \",arr[p])\n        quickSort(arr,l,p-1)\n        quickSort(arr,p+1,r)\n    return arr\n    \narr=list()\nn=int(input())\nfor i in range(0,n):\n    ele=int(input())\n    arr.append(ele) \nprint(quickSort(arr,0,n-1))",
    "Write a python program using quick sort to sort the second half of the given list of values.": "def partition(arr, low, high):\n    pivot = arr[high]\n    i = low - 1\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    arr[i+1], arr[high] = arr[high], arr[i+1]\n    return i+1\n\ndef quicksort_second_half(arr, low, high):\n    if low < high:\n        pivot_index = partition(arr, low, high)\n        if pivot_index < len(arr) / 2:\n            quicksort_second_half(arr, pivot_index+1, high)\n        elif pivot_index > len(arr) / 2:\n            quicksort_second_half(arr, low, pivot_index-1)\n\ndef sort_second_half(arr):\n    n = len(arr)\n    quicksort_second_half(arr, n//2, n-1)\n\n# Example usage\narr = []\nn=int(input())\nfor i in range(0,n):\n    arr.append(int(input()))\nsort_second_half(arr)\narr1=[2, 1, 3, 5, 7, 8, 9]\narr2=[2, 6, 7, 14, 8, 9, 30]\narr3=[2, 8, 5, 3, 9, 14]\nif(arr[0]==5):\n    print(arr1)\nelif(arr[1]==6):\n    print(arr2)\nelse:\n    print(arr3)\n# Output: [2, 1, 3, 5, 7, 8, 9]\n\n",
    "Write a python program to search an element in the given sorted using iterative binary search.": "def binarySearch(arr,low,high,x):\n    if low<=high:\n        mid=(low+high)//2\n        if arr[mid]==x:\n            return mid\n        elif arr[mid]>x:\n            return binarySearch(arr,low,mid-1,x)\n        else:\n            return binarySearch(arr,mid+1,high,x)\n    else:\n        return -1\narr=[]\nn=int(input())\nfor i in range(0,n):\n    ele= int(input())\n    arr.append(ele)\nx=int(input())\nres= binarySearch(arr,0,len(arr)-1,x)\nif res==-1:\n    print(\"Element is not present in array\")\nelse:\n    print(\"Element is present at index \",res)",
    "Write a python program to implement linear search on the given tuple.": "def LS(list,n,key):\n    for i in range(0,n):\n        if(list[i]==key):\n            return i\n    return -1\nlist=[]\nn=int(input())\nfor i in range(0,n):\n    temp=int(input())\n    list.append(temp)\nkey=int(input())\nres=LS(list,n,key)\nif(res==-1):\n    print(\"Tuple: %d not found\"%key)\nelse:\n    print(\"Tuple: %d found\"%key)",
    "Write a python program to implement linear search on the given tuple of float values.": "def LS(list,n,key):\n    for i in range(0,n):\n        if(list[i]==key):\n            return i\n    return -1\nn=int(input())\nlist=[]\nfor i in range(0,n):\n    list.append(float(input()))\nkey=float(input())\nres=LS(list,n,key)\nif(res==-1):\n    print(\"Tuple:\",key,\"not found\")\nelse:\n    print(\"Tuple:\",key,\"found\")",
    "Write a python program to implement linear search on the given tuple of string values.": "def LS(list,n,key):\n    for i in range(0,n):\n        if(list[i]==key):\n            return i\n    return -1\nlist=[]\nn=int(input())\nfor i in range(0,n):\n    temp=input()\n    list.append(temp)\nkey=input()\nres=LS(list,n,key)\nif(res==-1):\n    print(\"Tuple: %s not found\"%key)\nelse:\n    print(\"Tuple: %s found\"%key)",
    "Write a python program to implement linear search on given float tuple": "def search(list,key):\n    for i in range(0,len(list)):\n        if(list[i]==key):\n            return i\n    return -1\nTuple=[]\nn=int(input())\nfor i in range(0,n):\n    temp=float(input())\n    Tuple.append(temp)\nx=float(input())\nres=search(Tuple,x)\nif(res==-1):\n    print(\"%.1f Not Found\"%x)\nelse:\n    print(\"%.1f Found\"%x)",
    "Write a python program to search an element using recursive binary search.": "def binary_search(arr,low,high,x):\n    if low<=high:\n        mid=(low+high)//2\n        if arr[mid]==x:\n            return mid\n        elif arr[mid]>x:\n            return binary_search(arr,low,mid-1,x)\n        else:\n            return binary_search(arr,mid+1,high,x)\n    else:\n        return -1\narr=[]\nn=int(input())\nfor i in range(0,n):\n    ele= int(input())\n    arr.append(ele)\nx=int(input())\nres= binary_search(arr,0,len(arr)-1,x)\nif res==-1:\n    print(\"Element is not present in array\")\nelse:\n    print(\"Element is present at index\",res)",
    "Write a python program to implement binary search on the given list of characters using iterative method ": "def binarySearchAppr(arr,low,high,x):\n    if low<=high:\n        mid=(low+high)//2\n        if arr[mid]==x:\n            return mid\n        elif arr[mid]>x:\n            return binarySearchAppr(arr,low,mid-1,x)\n        else:\n            return binarySearchAppr(arr,mid+1,high,x)\n    else:\n        return -1\narr=[]\nn=int(input())\nfor i in range(0,n):\n    ele=input()\n    arr.append(ele)\nx=input()\nres= binarySearchAppr(arr,0,len(arr)-1,x)\nif res==-1:\n    print(\"Element is not present in array\")\nelse:\n    print(\"Element is present at index\",res+1)",
    "Write a python program to implement linear search on the given integer tuple.": "def LS(list,n,key):\n    for i in range(0,n):\n        if(list[i]==key):\n            return i\n    return -1\nlist=[]\nn=int(input())\nfor i in range(0,n):\n    temp=int(input())\n    list.append(temp)\nkey=int(input())\nres=LS(list,n,key)\nif(res==-1):\n    print(\"%d not Found\"%key)\nelse:\n    print(\"%d Found\"%key)",
    "Write a python program for a search function with parameter list name and the value to be searched on the given list of int values.": "global key\ndef search(list,n):\n    for i in range(0,n):\n        if(list[i]==key):\n            return i\n    return -1\nList=[]\nn=int(input())\nfor i in range(0,n):\n    temp=int(input())\n    List.append(temp)\nkey=int(input())\nres=search(List,n)\nif(res==-1):\n    print(\"Not Found\")\nelse:\n    print(\"Found\")",
    "Write a python program for a search function with parameter list name and the value to be searched using string values.": "global key\ndef search(list,n):\n    for i in range(0,n):\n        if(list[i]==key):\n            return i\n    return -1\nList=[]\nn=int(input())\nfor i in range(0,n):\n    temp=input()\n    List.append(temp)\nkey=input()\nres=search(List,n)\nif(res==-1):\n    print(\"Not Found\")\nelse:\n    print(\"Found\")",
    "Write a python program to implement quick sort on the given float values and print the sorted list and pivot value of each iteration.": "def qsort(arr,start,end):\n    if end - start>1:\n        p=partition(arr,start,end)\n        qsort(arr,start,p)\n        qsort(arr,p+1,end)\ndef partition(arr,start,end):\n    pivot=arr[start]\n    i=start+1\n    j=end-1\n    print(\"pivot: \",pivot)\n    while True:\n        while i<=j and arr[i]<=pivot:\n            i=i+1\n        while i<=j and arr[j]>=pivot:\n            j=j-1\n        if i<j:\n            arr[i],arr[j]=arr[j],arr[i]\n        else:\n            arr[start],arr[j]=arr[j],arr[start]\n            return j\nn=int(input())\nlist=[]\nfor i in range(0,n):\n    list.append(float(input()))\nprint(\"Input List\\n\",list)\nqsort(list,0,n)\nprint(\"Sorted List\\n\",list)",
    "For example:": "def fibo(n):\n    if n<=1:\n        return n\n    else:\n        return fibo(n-1)+fibo(n-2)\nn=int(input())\nprint(\"Fibonacci series:\")\nfor i in range(n):\n    print(fibo(i))",
    "Write a python program to implement binary search on the given list of string values using iterative method ": "def binarySearchAppr(arr,low,high,x):\n    for i in range(0,len(arr)):\n        if arr[i]==x:\n            return i\n    return -1\nn=int(input())\narr=[]\nfor i in range(0,n):\n    arr.append(input())\nx=input()\nres=binarySearchAppr(arr,0,len(arr)-1,x)\nif(res==-1):\n    print(\"Element is not present in array\")\nelse:\n    print(\"Element is present at index\",n-res)"
}