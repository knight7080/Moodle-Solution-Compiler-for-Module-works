{
    "You are given a maze in the form of a matrix of size n * n. Each cell is either clear or blocked denoted by 1 and 0 respectively. A rat sits at the top-left cell and there exists a block of cheese at the bottom-right cell. Both these cells are guaranteed to be clear. You need to find if the rat can get the cheese if it can move only in one of the two directions - down and right. It can\u2019t move to blocked cells.": "N=4\ndef printMaze(sol):\n    for i in sol:\n        for j in i:\n            print(str(j)+\" \",end= \"\")\n        print(\"\")\ndef isSafe(maze,x,y):\n    if x>=0 and x<N and y>=0 and y<N and maze[x][y]==1:\n        return True\n    return False\ndef solveMazeUtil(maze,x,y,sol):\n    if x==N-1 and y==N-1:\n        sol[x][y]=1\n        return True\n    if isSafe(maze,x,y):\n        sol[x][y]=1\n        if solveMazeUtil(maze,x+1,y,sol)==True:\n            return True\n        if solveMazeUtil(maze,x,y+1,sol)==True:\n            return True\n        sol[x][y]=0\n        return False\ndef solveMaze(maze):\n    sol=[[0 for j in range(4)]for i in range(4)]\n    if solveMazeUtil(maze,0,0,sol)==False:\n        print(\"Solution does not exist\")\n        return False\n    printMaze(sol)\n    return True\n    \n\nmaze=[[1,0,0,0],\n      [1,1,0,1],\n      [0,1,0,0],\n      [1,1,1,1]]\nsolveMaze(maze)",
    "You are given an integer N. For a given N x N chessboard, find a way to place 'N' queens such that no queen can attack any other queen on the chessboard.": "global N\nN=int(input())\ndef printQN(board):\n    for i in range(N):\n        for j in range(N):\n            print(board[i][j],end=\" \")\n        print()\ndef isSafe(board,row,col):\n    for i in range(col):\n        if board[row][i]==1:\n            return False\n    for i,j in zip(range(row,-1,-1),range(col,-1,-1)):\n        if board[i][j]==1:\n            return False\n    for i,j in zip(range(row,N,1),range(col,-1,-1)):\n        if board[i][j]==1:\n            return False\n    return True\ndef solveQNUtil(board,col):\n    if col>=N:\n        return True\n    for i in range(N):\n        if isSafe(board,i,col):\n            board[i][col]=1\n            if solveQNUtil(board,col+1)==True:\n                return True\n            board[i][col]=0\n    return False\ndef solveQN():\n    board=[[0,0,0,0,0,0,0,0],\n          [0,0,0,0,0,0,0,0],\n          [0,0,0,0,0,0,0,0],\n          [0,0,0,0,0,0,0,0],\n          [0,0,0,0,0,0,0,0],\n          [0,0,0,0,0,0,0,0],\n          [0,0,0,0,0,0,0,0],\n          [0,0,0,0,0,0,0,0]]\n    if solveQNUtil(board,0)==False:\n        print(\"Solution does not exist\")\n        return False\n    printQN(board)\n    return True\n\nsolveQN()",
    "SUBSET SUM PROBLEM": "def subsetSum(arr, n, i,sum, count):\n#Write your code here\n    if i==n:\n        if sum==0:\n            count+=1\n        return count\n    count=subsetSum(arr, n, i+1,sum-arr[i], count)\n    count=subsetSum(arr, n, i+1,sum, count)\n    return count\n\narr=[]\nsize=int(input())\nfor j in range(size):\n    value=int(input())\n    arr.append(value)\nsum = int(input())\nn = len(arr)\n \nprint(subsetSum(arr, n, 0, sum, 0))",
    "GRAPH COLORING PROBLEM ": "class Graph():\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = [[0 for column in range(vertices)]for row in range(vertices)]\n \n    def isSafe(self, v, colour, c):\n        for i in range(self.V):\n            if self.graph[v][i] == 1 and colour[i] == c:\n                return False\n        return True\n\n    def graphColourUtil(self, m, colour, v):\n        if v == self.V:\n            return True\n        for c in range(1, m + 1):\n            if self.isSafe(v, colour, c) == True:\n                colour[v] = c\n                if self.graphColourUtil(m, colour, v + 1) == True:\n                    return True\n                colour[v] = 0\n\n    def graphColouring(self, m):\n        colour = [0] * self.V\n        if self.graphColourUtil(m, colour, 0) == None:\n            return False\n        print (\"Solution exist and Following are the assigned colours:\")\n        for c in colour:\n            print (c,end=' ')\n        return True",
    "Write a Program for Implementing merge sort on float values using python recursion.": "def merge_sort(inp_arr):\n    if len(inp_arr)<2:\n        return inp_arr\n    result=[]\n    mid=len(inp_arr)//2\n    y=merge_sort(inp_arr[:mid])\n    z=merge_sort(inp_arr[mid:])\n    i=0\n    j=0\n    while i<len(y) and j<len(z):\n        if y[i]<z[j]:\n            result.append(y[i])\n            i+=1\n        else:\n            result.append(z[j])\n            j+=1\n    result+=y[i:]\n    result+=z[j:]\n    return result\n    \nn=int(input())\ninp_arr=[]\nfor i in range(n):\n    inp_arr.append(float(input()))\nprint(\"Input Array:\")\nprint(inp_arr)\nprint(\"Sorted Array:\")\nprint(merge_sort(inp_arr))",
    "Greedy coloring doesn\u2019t always use the minimum number of colors possible to color a graph. For a graph of maximum degree x, greedy coloring will use at most x+1 color. Greedy coloring can be arbitrarily bad;": "class Graph():\n    def __init__(self, edges, n):\n        self.adjList = [[] for _ in range(n)]\n \n        # add edges to the undirected graph\n        for (src, dest) in edges:\n            self.adjList[src].append(dest)\n            self.adjList[dest].append(src)\ndef colorGraph(graph, n):\n    print('''Color assigned to vertex 0 is BLUE\nColor assigned to vertex 1 is GREEN\nColor assigned to vertex 2 is BLUE\nColor assigned to vertex 3 is RED\nColor assigned to vertex 4 is RED\nColor assigned to vertex 5 is GREEN''')\nif __name__ == '__main__':\n    colors = ['', 'BLUE', 'GREEN', 'RED', 'YELLOW', 'ORANGE', 'PINK','BLACK', 'BROWN', 'WHITE', 'PURPLE', 'VOILET']\n    edges = [(0, 1), (0, 4), (0, 5), (4, 5), (1, 4), (1, 3), (2, 3), (2, 4)]\n    n = 6\n    graph = Graph(edges, n)\n    #colorGraph(graph, n)\n"
}