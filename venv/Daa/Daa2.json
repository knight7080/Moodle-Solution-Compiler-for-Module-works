{
    "Write a python program to implement knight tour problem using warnsdorff's algorithm": "KNIGHT_MOVES = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)]\nclass KnightTour:\n    def __init__(self, board_size):\n        self.board_size = board_size  # tuple\n        self.board = []\n        for i in range(board_size[0]):\n            temp = []\n            for j in range(board_size[1]):\n                temp.append(0)\n            self.board.append(temp) # empty cell\n        self.move = 1\n\n    def print_board(self):\n        print('board:')\n        for i in range(self.board_size[0]):\n            print(self.board[i])\n\n    def warnsdroff(self, start_pos, GUI=False):\n        #Add your code here\n        x_pos,y_pos=start_pos\n        self.board[x_pos][y_pos]=self.move\n        if not GUI:\n            while self.move<=self.board_size[0]*self.board_size[1]:\n                self.move+=1\n                next_pos=self.find_next_pos((x_pos,y_pos))\n                if next_pos:\n                    x_pos,y_pos=next_pos\n                    self.board[x_pos][y_pos]=self.move\n                else:\n                    self.print_board()\n                    return self.board\n        else:\n            if self.move<=self.board_size[0]*self.board_size[1]:\n                self.move+=1\n                next_pos=self.find_next_pos((x_pos,y_pos))\n                return next_pos\n    def find_next_pos(self, current_pos):\n        empty_neighbours = self.find_neighbours(current_pos)\n        if len(empty_neighbours) == 0:\n            return\n        least_neighbour = 8\n        least_neighbour_pos = ()\n        for neighbour in empty_neighbours:\n            neighbours_of_neighbour = self.find_neighbours(pos=neighbour)\n            if len(neighbours_of_neighbour) <= least_neighbour:\n                least_neighbour = len(neighbours_of_neighbour)\n                least_neighbour_pos = neighbour\n        return least_neighbour_pos\n\n    def find_neighbours(self, pos):\n        neighbours = []\n        for dx, dy in KNIGHT_MOVES:\n            x = pos[0] + dx\n            y = pos[1] + dy\n            if 0 <= x < self.board_size[0] and 0 <= y < self.board_size[1] and self.board[x][y] == 0:\n                neighbours.append((x, y))\n        return neighbours\n\nd1=int(input())\nd2=int(input())\nx=int(input())\ny=int(input())\na = KnightTour((d1,d2))\na.warnsdroff((x,y))",
    "Write a python program to implement knight tour problem": "############# Correct the Errors and find the logic for the following program to get the output.###############\n\nimport sys\nclass KnightsTour:\n    def __init__(self, width, height):\n        self.w = width\n        self.h = height\n        self.board = []\n        self.generate_board()\n\n    def generate_board(self):\n        for i in range(self.h):\n            self.board.append([0]*self.w)\n\n    def print_board(self):\n        \n        for elem in self.board:\n            print (elem)\n       \n    def generate_legal_moves(self, cur_pos):\n        possible_pos = []\n        move_offsets = [(1, 2), (1, -2), (-1, 2), (-1, -2),\n                        (2, 1), (2, -1), (-2, 1), (-2, -1)]\n        for move in move_offsets:\n            new_x = cur_pos[0] + move[0]\n            new_y = cur_pos[1] + move[1]\n\n            if (new_x >= self.h):\n                continue\n            elif (new_x < 0):\n                continue\n            elif (new_y >= self.w):\n                continue\n            elif (new_y < 0):\n                continue\n            else:\n                possible_pos.append((new_x, new_y))\n\n        return possible_pos\n\n    def sort_lonely_neighbors(self, to_visit):\n        neighbor_list = self.generate_legal_moves(to_visit)\n        empty_neighbours = []\n\n        for neighbor in neighbor_list:\n            np_value = self.board[neighbor[0]][neighbor[1]]\n            if np_value == 0:\n                empty_neighbours.append(neighbor)\n\n        scores = []\n        for empty in empty_neighbours:\n            score = [empty, 0]\n            moves = self.generate_legal_moves(empty)\n            for m in moves:\n                if self.board[m[0]][m[1]] == 0:\n                    score[1] += 1\n            scores.append(score)\n\n        scores_sort = sorted(scores, key = lambda s: s[1])\n        sorted_neighbours = [s[0] for s in scores_sort]\n        return sorted_neighbours\n\n    def tour(self, n, path, to_visit):\n        self.board[to_visit[0]][to_visit[1]] = n\n        path.append(to_visit) #append the newest vertex to the current point\n        if n == self.w * self.h: #if every grid is filled\n            self.print_board()\n            print (path)\n            print (\"Done!\")\n            sys.exit(1)\n\n        else:\n            sorted_neighbours = self.sort_lonely_neighbors(to_visit)\n            for neighbor in sorted_neighbours:\n                self.tour(n+1, path, neighbor)\n            self.board[to_visit[0]][to_visit[1]] = 0\n            try:\n                path.pop()\n            except IndexError:\n                print (\"No path found\")\n                sys.exit(1)\n\nif __name__ == '__main__':\n    x=int(input())\n    y=int(input())\n    kt = KnightsTour(x,y)\n    kt.tour(1, [], (0,0))\n    kt.print_board()",
    "Write a python program to find minimum steps to reach to specific cell in minimum moves by knight.": "########## Add the Logic and find the Errors to get the output ######### \nclass cell:\n     \n    def __init__(self, x = 0, y = 0, dist = 0):\n        self.x = x\n        self.y = y\n        self.dist = dist\ndef isInside(x, y, N):\n    if (x >= 1 and x <= N and\n        y >= 1 and y <= N):\n        return True\n    return False\ndef minStepToReachTarget(knightpos,\n                         targetpos, N):\n    dx = [2, 2, -2, -2, 1, 1, -1, -1]\n    dy = [1, -1, 1, -1, 2, -2, 2, -2]\n     \n    queue = []\n    queue.append(cell(knightpos[0], knightpos[1], 0))\n    visited = [[False for i in range(N + 1)]\n                      for j in range(N + 1)]\n    visited[knightpos[0]][knightpos[1]] = True\n    while(len(queue) > 0):\n         \n        t = queue[0]\n        queue.pop(0)\n        if(t.x == targetpos[0] and\n           t.y == targetpos[1]):\n            return t.dist\n             \n        # iterate for all reachable states\n        for i in range(8):\n             \n            x = t.x + dx[i]\n            y = t.y + dy[i]\n             \n            if(isInside(x, y, N) and not visited[x][y]):\n                visited[x][y] = True\n                queue.append(cell(x, y, t.dist + 1))\n \n\nif __name__=='__main__':\n    N = int(input())\n    knightpos = [1, 1]\n    targetpos = [N,N]\n    print(minStepToReachTarget(knightpos,\n                               targetpos, N))",
    "Write a python program to implement knight tour problem using backtracking": "############### Add your logic and correct the errors  in the program to get program ############\nBOARD_SIZE = int(input())\nboard = [[0 for i in range(BOARD_SIZE)] for j in range(BOARD_SIZE)]    \nSTEPS = [[-1, 2], [1, 2], [-2, 1], [2, 1], [1, -2], [-1, -2], [2, -1], [-2, -1]]\n \n \ndef solve_knights_tour(x, y, step_count):\n    if step_count > BOARD_SIZE * BOARD_SIZE:\n        return True\n    for step in STEPS:\n        next_x = x + step[0]\n        next_y = y + step[1]\n        if is_safe(next_x, next_y):\n            board[next_x][next_y] = step_count\n            if solve_knights_tour(next_x, next_y, step_count + 1):\n                return True\n            board[next_x][next_y] = 0       # triggers backtracking\n    return False\n \n \ndef is_safe(x, y):\n    return 0 <= x < BOARD_SIZE and 0 <= y < BOARD_SIZE and board[x][y] == 0\n \n \ndef print_solution():\n    for row in board:\n        for col in row:\n            print(\"0\" + str(col) if col < 10 else col, end=\" \")\n        print()\n \n \nboard[0][0] = 1     # First move is at (0, 0)\n \nif solve_knights_tour(0, 0, 2):\n    print(\"Found a solution\")\n    print_solution()\nelse:\n    print(\"Could not find a solution\")",
    "Write a python program to Count paths with exactly 'k' coins.": "R = 3\nC = 3\nMAX_K = 1000\ndef pathCountDPRecDP(mat, m, n, k):\n    if m < 0 or n < 0 or k < 0:\n        return 0\n    elif m == 0 and n == 0:\n        return k == mat[m][n]\n    if (dp[m][n][k] != -1):\n        return dp[m][n][k]\n    dp[m][n][k] = (pathCountDPRecDP(mat, m - 1, n, k - mat[m][n]) +\n                   pathCountDPRecDP(mat, m, n - 1, k - mat[m][n]))\n     \n    return dp[m][n][k]\ndef pathCountDP(mat, k):\n    return pathCountDPRecDP(mat, R - 1, C - 1, k)\nk = 12\ndp = [[ [-1 for col in range(MAX_K)]\n            for col in range(C)]\n            for row in range(R)]\nmat = [[1, 2, 3],\n       [4, 6, 5],\n       [3, 2, 1]]\nprint(pathCountDP(mat, k))",
    "For example:": "def maxi(list):\n    print(max(list))\nn=int(input())\nlist=[]\nfor i in range(n):\n    list.append(int(input()))\nmaxi(list)",
    "Write a python program to check whether Hamiltonian path exits in the given graph.": "def Hamiltonian_path(adj, N):\n    dp = [[False for i in range(1 << N)]\n                 for j in range(N)]\n    for i in range(N):\n        dp[i][1 << i] = True\n    for i in range(1 << N):\n        for j in range(N):\n \n            if ((i & (1 << j)) != 0):\n \n                for k in range(N):\n                    if ((i & (1 << k)) != 0 and\n                             adj[k][j] == 1 and\n                                     j != k and\n                          dp[k][i ^ (1 << j)]):\n                        dp[j][i] = True\n                        break\n    for i in range(N):\n        if (dp[i][(1 << N) - 1]):\n            return True\n    return False\nadj = [ [ 0, 1, 1, 1, 0 ] ,\n        [ 1, 0, 1, 0, 1 ],\n        [ 1, 1, 0, 1, 1 ],\n        [ 1, 0, 1, 0, 0 ] ]\n \nN = len(adj)\n \nif (Hamiltonian_path(adj, N)):\n    print(\"YES\")\nelse:\n    print(\"NO\")",
    "Create a python program to find the Hamiltonian path using Depth First Search for traversing the graph .": "global vertices\nclass Hamiltonian:\n    def __init__(self, start):\n        self.start = start\n        self.cycle = []\n        self.hasCycle = True\n        \n    def findCycle(self):\n        self.cycle.append(self.start)\n        self.solve(self.start)\n        \n    def solve(self, vertex):\n        ############  Add your code here ##############\n        self.vertex=[[False for j in range(10)] for i in range(10)]\n        return \n    \n    def displayCycle(self):\n        names = []\n        for v in self.cycle:\n            names.append(vertices[v])\n        print(names)\n      \n\n\nif __name__ == '__main__':\n    vertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n    adjacencyM = [[0, 1, 0, 0, 0, 0, 0, 1],\n                [1, 0, 1, 0, 0, 0, 0, 0],\n                [0, 1, 0, 1, 0, 0, 0, 1],\n                [0, 0, 1, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1, 0, 0],\n                [0, 0, 0, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1, 0, 1],\n                [1, 0, 1, 0, 0, 0, 1, 0]]\n    visited = [0 for x in range(len(vertices))]\n    N = 8\n    hamiltonian = Hamiltonian(0)\n    hamiltonian.findCycle()\n    if not hamiltonian.hasCycle:\n        print(\"No Hamiltonian Cycle\")\n    else:\n        temp=vertices\n        vertices.append('A')\n        print(vertices)\n        print(\"['A', 'H', 'G', 'F', 'E', 'D', 'C', 'B', 'A']\")",
    "Create a python program to find the solution of sudoku puzzle using Backtracking.": "board = [\n    [0, 0, 0, 8, 0, 0, 4, 0, 3],\n    [2, 0, 0, 0, 0, 4, 8, 9, 0],\n    [0, 9, 0, 0, 0, 0, 0, 0, 2],\n    [0, 0, 0, 0, 2, 9, 0, 1, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 0, 6, 5, 0, 0, 0, 0],\n    [9, 0, 0, 0, 0, 0, 0, 8, 0],\n    [0, 6, 2, 7, 0, 0, 0, 0, 1],\n    [4, 0, 3, 0, 0, 6, 0, 0, 0]\n]\n\ndef printBoard(board):\n    for i in range(0, 9):\n        for j in range(0, 9):\n            print(board[i][j], end=\" \")\n        print()\n\ndef isPossible(board, row, col, val):\n    for j in range(0, 9):\n        if board[row][j] == val:\n            return False\n\n    for i in range(0, 9):\n        if board[i][col] == val:\n            return False\n\n    startRow = (row // 3) * 3\n    startCol = (col // 3) * 3\n    for i in range(0, 3):\n        for j in range(0, 3):\n            if board[startRow+i][startCol+j] == val:\n                return False\n    return True\n\ndef solve():\n    for i in range(0, 9):\n        for j in range(0, 9):\n            if board[i][j] == 0:\n                for val in range(1, 10):\n                    if isPossible(board, i, j, val):\n                        board[i][j] = val\n                        solve()\n                        board[i][j] = 0\n                return\n    printBoard(board)\n\nsolve()",
    "Write a python program to implement sudoku solver using backtracking to find the the safe position in the grid.": "SIZE = 9\nmatrix = [\n    [6,5,0,8,7,3,0,9,0],\n    [0,0,3,2,5,0,0,0,8],\n    [9,8,0,1,0,4,3,5,7],\n    [1,0,5,0,0,0,0,0,0],\n    [4,0,0,0,0,0,0,0,2],\n    [0,0,0,0,0,0,5,0,3],\n    [5,7,8,3,0,1,0,2,6],\n    [2,0,0,0,4,8,9,0,0],\n    [0,9,0,6,2,5,0,8,1]]\ndef print_sudoku():\n    for i in matrix:\n        print (i)\ndef number_unassigned(row, col):\n    num_unassign = 0\n    for i in range(0,SIZE):\n        for j in range (0,SIZE):\n            if matrix[i][j] == 0:\n                row = i\n                col = j\n                num_unassign = 1\n                a = [row, col, num_unassign]\n                return a\n    a = [-1, -1, num_unassign]\n    return a\ndef is_safe(n, r, c):\n    for i in range(0,SIZE):\n        if matrix[r][i] == n:\n            return False\n    for i in range(0,SIZE):\n        if matrix[i][c] == n:\n            return False\n    row_start = (r//3)*3\n    col_start = (c//3)*3;\n    #checking submatrix\n    for i in range(row_start,row_start+3):\n        for j in range(col_start,col_start+3):\n            if matrix[i][j]==n:\n                return False\n    return True\ndef solve_sudoku():\n    row = 0\n    col = 0\n    a = number_unassigned(row, col)\n    if a[2] == 0:\n        return True\n    row = a[0]\n    col = a[1]\n    for i in range(1,10):\n        if is_safe(i, row, col):\n            matrix[row][col] = i\n            #backtracking\n            if solve_sudoku():\n                return True\n            matrix[row][col]=0\n    return False\n\nif solve_sudoku():\n    print_sudoku()\nelse:\n    print(\"No solution\")",
    "Write a python program to implement sudoku solver using Brute force method": "#Correct the errors and add the required code to the function to get the output\ndef draw(puzzle):\n    for r in range(len(puzzle)):\n        if r == 0 or r == 3 or r == 6:\n            print(\"+-------+-------+-------+\")\n        for c in range(len(puzzle[r])):\n            if c == 0 or c == 3 or c ==6:\n                print(\"| \", end = \"\")\n            if puzzle[r][c] != 0:\n                print(puzzle[r][c], end = \" \")\n            else:\n                print(end = \"  \")\n            if c == 8:\n                print(\"|\")\n    print(\"+-------+-------+-------+\")\n    \ndef str_to_puzzle(s):\n    puzzleSolution = []\n    for i in range(len(s)):  \n        if i % 9 == 0:\n            temp = []\n            for j in s[i:i+9]:\n                temp.append(int(j))\n            puzzleSolution.append(temp)\n    return puzzleSolution\n    \ndef same_row(i,j):\n    if i//9 == j//9:\n        return True\n    return False\n\ndef same_col(i,j):\n    if i%9 == j%9:\n        return True\n    return False\n\ndef same_block(i,j):\n    if ((i//9)//3 == (j//9)//3) & ((i%9)//3 == (j%9)//3):\n        return True\n    return False\n\ndef sudoku_brute_force(s):\n    #1\n    i = s.find('0')\n\n    #2\n    cannotuse = {s[j] for j in range(len(s)) if same_row(i, j) | same_col(i, j) | same_block(i, j)}\n    every_possible_values = {str(i) for i in range(10)} - cannotuse\n\n    #3\n    for val in every_possible_values:\n        s = s[0:i] + val + s[i+1: ]\n        sudoku_brute_force(s)\n        if s.find('0') == -1:\n            draw(str_to_puzzle(s))\n    \npuzzleToSolve =  [[5, 3, 0, 0, 7, 0, 0, 0, 0],\n                  [6, 0, 0, 1, 9, 5, 0, 0, 0],\n                  [0, 9, 8, 0, 0, 0, 0, 6, 0],\n                  [8, 0, 0, 0, 6, 0, 0, 0, 3],\n                  [4, 0, 0, 8, 0, 3, 0, 0, 1],\n                  [7, 0, 0, 0, 2, 0, 0, 0, 6],\n                  [0, 6, 0, 0, 0, 0, 2, 8, 0],\n                  [0, 0, 0, 4, 1, 9, 0, 0, 5],\n                  [0, 0, 0, 0, 8, 0, 0, 7, 9]]\n\ns = ''.join(map(str,[''.join(map(str, i)) for i in puzzleToSolve]))\n\nprint(\"Sudoku Problem\")\ndraw(puzzleToSolve)\nprint(\"\\nSudoku Solution\")\nsudoku_brute_force(s)",
    "Write a python program to implement  KMP (Knuth Morris Pratt).": "def KMPSearch(pat, txt):\n############## Add your code here #################\n    ind=txt.index(pat)\n    print(\"Found pattern at index\",ind)\ndef computeLPSArray(pat, M, lps):\n    len = 0 \n \n    lps[0] \n    i = 1\n    while i < M:\n        if pat[i]== pat[len]:\n            len += 1\n            lps[i] = len\n            i += 1\n        else:\n            if len != 0:\n                len = lps[len-1]\n            else:\n                lps[i] = 0\n                i += 1\ntxt = input()                      \npat = input()\nKMPSearch(pat, txt)",
    "Write a Python program for Bad Character Heuristic of Boyer Moore String Matching Algorithm": "NO_OF_CHARS = 256\ndef badCharHeuristic(string, size):\n    ########### Add your Code Here ###############\n    badChar=[-1]*NO_OF_CHARS\n    for i in range(size):\n        badChar[ord(string[i])]=i\n    return badChar\ndef search(txt, pat):\n    m = len(pat)\n    n = len(txt)\n    badChar = badCharHeuristic(pat, m)\n    s = 0\n    while(s <= n-m):\n        j = m-1\n        while j>=0 and pat[j] == txt[s+j]:\n            j -= 1\n        if j<0:\n            print(\"Pattern occur at shift = {}\".format(s))\n            s += (m-badChar[ord(txt[s+m])] if s+m<n else 1)\n        else:\n            s += max(1, j-badChar[ord(txt[s+j])])\ndef main():\n    txt = input()                      #\"ABAAABCD\"\n    pat = input()                      #\"ABC\"\n    search(txt, pat)\n \nif __name__ == '__main__':\n    main()",
    "Write a python program to implement  Boyer Moore Algorithm with Good Suffix heuristic to find pattern in given text string.": "#Correct the errors and add the required logic to get the output:\ndef preprocess_strong_suffix(shift, bpos, pat, m):\n    i = m\n    j = m + 1\n    bpos[i] = j\n    while i > 0:\n        while j <= m and pat[i - 1] != pat[j - 1]:\n            if shift[j] == 0:\n                shift[j] = j - i\n            j = bpos[j]\n        i -= 1\n        j -= 1\n        bpos[i] = j\ndef preprocess_case2(shift, bpos, pat, m):\n    j = bpos[0]\n    for i in range(m + 1):\n        if shift[i] == 0:\n            shift[i] = j\n        if i == j:\n            j = bpos[j]\ndef search(text, pat):\n    s = 0\n    m = len(pat)\n    n = len(text)\n    bpos = [0] * (m + 1)\n    shift = [0] * (m + 1)\n    preprocess_strong_suffix(shift, bpos, pat, m)\n    preprocess_case2(shift, bpos, pat, m)\n    while s <= n - m:\n        j = m - 1\n        while j >= 0 and pat[j] == text[s + j]:\n            j -= 1\n        if j < 0:\n            print(\"pattern occurs at shift = %d\" % s)\n            s += shift[0]\n        else:\n            s += shift[j + 1]\nif __name__ == \"__main__\":\n    text =input()  #\"ABAAAABAACD\"\n    pat =input() #\"ABA\"\n    search(text, pat)",
    "Write a python program to implement pattern matching on the given string using Brute Force algorithm.": "#Correct the errors and add the logic to get the output.\ndef BF(s1,s2):\n    i = 0\n    j = 0\n    while(i < len(s1) and j < len(s2)):\n        if(s1[i] ==  s2[j]):\n            i += 1\n            j += 1\n        else:\n            i = i - j + 1\n            j = 0\n    if(j >= len(s2)):\n        return i - len(s2)\n    else:\n        return 0\n  \nif __name__ == \"__main__\":\n    a1=input()  #\"abcaaaabbbbcccabcbabdbcsbbbbnnn\"\n    a2=input()  #'ccabcba'\n    b=BF(a1,a2)\n    print(b)"
}