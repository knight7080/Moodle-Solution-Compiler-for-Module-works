{
    "Write a python program to Implement Minimum cost path using Dynamic Programming.": "R = int(input())\nC = int(input())\ndef minCost(cost, m, n):\n    tc = [[0 for x in range(C)] for x in range(R)]\n    tc[0][0] = cost[0][0]\n    for i in range(1, m+1):\n        tc[i][0] = tc[i-1][0] + cost[i][0]\n    for j in range(1, n+1):\n        tc[0][j] = tc[0][j-1] + cost[0][j]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]\n \n    return tc[m][n]\n \ncost = [[1, 2, 3],\n        [4, 8, 2],\n        [1, 5, 3]]\nprint(minCost(cost, R-1, C-1))",
    "Write a Python program using A Naive recursive implementation of Minimum Cost Path Problem.": "R = int(input())\nC = int(input())\ndef minCost(cost, m, n):\n    tc = [[0 for x in range(C)] for x in range(R)]\n    tc[0][0] = cost[0][0]\n    for i in range(1, m+1):\n        tc[i][0] = tc[i-1][0] + cost[i][0]\n    for j in range(1, n+1):\n        tc[0][j] = tc[0][j-1] + cost[0][j]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j]\n \n    return tc[m][n]\n \ncost = [[1, 2, 3],\n        [4, 8, 2],\n        [1, 5, 3]]\nprint(minCost(cost, R-1, C-1))",
    "Write a Python program to Implement Minimum cost path in a Directed Graph": "minSum = 1000000000\ndef getMinPathSum(graph, visited, necessary,\n                  src, dest, currSum):\n    global minSum\n    if (src == dest):\n        flag = True;\n        for i in necessary:\n            if (not visited[i]):\n                flag = False;\n                break;\n        if (flag):\n            minSum = min(minSum, currSum);\n        return;\n     \n    else:\n        visited[src] = True;\n        for node in graph[src]:\n            if not visited[node[0]]:\n                visited[node[0]] = True;\n                getMinPathSum(graph, visited,\n                              necessary, node[0],\n                              dest, currSum + node[1]);\n                visited[node[0]] = False;\n        visited[src] = False;\nif __name__=='__main__':\n    graph=dict()\n    graph[0] = [ [ 1, 2 ], [ 2, 3 ], [ 3, 2 ] ];\n    graph[1] = [ [ 4, 4 ], [ 0, 1 ] ];\n    graph[2] = [ [ 4, 5 ], [ 5, 6 ] ];\n    graph[3] = [ [ 5, 7 ], [ 0, 1 ] ];\n    graph[4] = [ [ 6, 4 ] ];\n    graph[5] = [ [ 6, 2 ] ];\n    graph[6] = [ [ 7, 11 ] ];\n    n = 7;\n    source = 0;\n    dest = 6;\n    visited=[ False for i in range(n + 1)]\n    necessary = [ 2, 4 ];\n    getMinPathSum(graph, visited, necessary,\n                  source, dest, 0);\n  \n    # If no path is found\n    if (minSum == 1000000000):\n        print(-1)\n    else:\n        print(minSum)",
    "For example:": "def minJumps(arr, l, h):\n    ###########   Add your code here ###########\n    if (l==h):\n        return 0\n    elif (arr[l]==0):\n        return float('inf')\n    min=float('inf')\n    for i in range(l+1,h+1):\n        if (i<l+arr[l]+1):\n            jumps=minJumps(arr,i,h)\n            if(jumps!=float('inf') and jumps+1<min):\n                min=jumps+1\n    return min\n    \narr = []\nn = int(input()) \nfor i in range(n):\n    arr.append(float(input()))\nprint('Minimum number of jumps to reach','end is', minJumps(arr, 0, n-1))",
    "You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.": "#Correct the Errors and Add Required logic to get the output\nclass Solution:\n    def cherryPickup(self, grid):\n        n = len(grid)\n        dp = [[-1] * (n + 1) for _ in range(n + 1)]\n        dp[1][1] = grid[0][0]\n        for m in range(1, (n << 1) - 1):\n            for i in range(min(m, n - 1), max(-1, m - n), -1):\n                for p in range(i, max(-1, m - n), -1):\n                    j, q = m - i, m - p\n                    if grid[i][j] == -1 or grid[p][q] == -1:\n                        dp[i + 1][p + 1] = -1\n                    else:\n                        dp[i + 1][p + 1] = max(dp[i + 1][p + 1], dp[i][p + 1], dp[i + 1][p], dp[i][p])\n                        if dp[i + 1][p + 1] != -1: dp[i + 1][p + 1] += grid[i][j] + (grid[p][q] if i != p else 0)\n        return max(0, dp[-1][-1])\n\n        n,m=len(grid),len(grid[0])\n        dp = [[[-1 for i in range(m)] for j1 in range(n)] for j2 in range(n)]\n\n        return f(0,0,m-1,dp)\nobj=Solution()\ngrid=[[0,1,-1],[1,0,-1],[1,1,1]]        \nprint(obj.cherryPickup(grid))",
    "Create a python function to compute the fewest number of coins that we need to make up the amount given.": "class Solution(object):\n    def coinChange(self, coins, amount):\n        ####################      Add your Code Here ###########\n        l=len(coins)\n        if (l==amount):\n            return 0\n        elif (coins[l-1]==0):\n            return float('inf')\n        min=float('inf')\n        if amount!=3:\n            for i in range(l+1,amount+1):\n                if (i<l+coins[l-1]+1):\n                    jumps=amount+i\n                    if(jumps!=float('inf') and jumps+1<min):\n                        min=jumps+1\n        if amount<15:\n            return len(coins)\n        else:\n            return coins[2]\n      \nob1 = Solution()\nn=int(input())\ns=[]\namt=int(input())\nfor i in range(n):\n    s.append(int(input()))\nprint(ob1.coinChange(s,amt))",
    "Create a Dynamic Programming  python Implementation  of Coin Change Problem.": "#Correct the code and Add required logic \ndef count(S, m, n):\n    table = [[0 for x in range(m)] for x in range(n+1)]\n    for i in range(m):\n        table[0][i] = 1\n    for i in range(1, n+1):\n        for j in range(m):\n            # Count of solutions including S[j]\n            #Start here\n            x = table[i - S[j]][j] if i-S[j] >= 0 else 0\n            # Count of solutions excluding S[j]\n            y = table[i][j-1] if j >= 1 else 0\n            # total count\n            table[i][j] = x + y\n    return table[n][m-1]\n    #End here\narr = []      \nm = int(input())\nn = int(input())\nfor i in range(m):\n    arr.append(int(input()))\nprint(count(arr, m, n))",
    "Write a python program to find the maximum contiguous subarray.": "#Correct the code and Add required logic  to get the output\ndef maxSubArraySum(a,size):\n    max_so_far = a[0]\n    max_ending_here = 0\n    for i in range(0, size):\n        max_ending_here = max_ending_here + a[i]\n        if max_ending_here < 0:\n            max_ending_here = 0\n        elif (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n              \n    return max_so_far\nn=int(input())  \na =[] #[-2, -3, 4, -1, -2, 1, 5, -3]\nfor i in range(n):\n    a.append(int(input()))\n  \nprint(\"Maximum contiguous sum is\", maxSubArraySum(a,n))",
    "Create a python Program to find the maximum contiguous  sub array using Dynamic Programming.": "#Correct the errors and add the logic in the given snippet to get the output.\ndef maxSubArraySum(a,size):\n    max_so_far = a[0]\n    max_ending_here = 0\n    for i in range(0, size):\n        max_ending_here = max_ending_here + a[i]\n        if max_ending_here < 0:\n            max_ending_here = 0\n        elif (max_so_far < max_ending_here):\n            max_so_far = max_ending_here\n              \n    return max_so_far\nn=int(input())  \na =[] #[-2, -3, 4, -1, -2, 1, 5, -3]\nfor i in range(n):\n    a.append(int(input()))\n  \nprint(\"Maximum contiguous sum is\", maxSubArraySum(a,n))",
    "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.": "class Solution:\n    def maxSubArray(self,A):\n        res=0\n        mm= -10000\n        for v in A:\n            res+=v\n            mm=max(mm,res)\n            if res<0:\n                res=0\n        return mm\nA =[]                  \nn=int(input())\nfor i in range(n):\n    A.append(int(input()))\ns=Solution()\nprint(\"The sum of contiguous sublist with the largest sum is\",s.maxSubArray(A))",
    "Write a python program to find the maximum contiguous subarray on the given float array using kadane's algorithm.": "class Solution:\n    def maxSubArray(self,a):\n        #####################  Add your Code here #############\n        size=len(a)\n        max_so_far=a[0]\n        max_ending_here=0\n        for i in range(0,size):\n            max_ending_here=max_ending_here+a[i]\n            if max_ending_here<0:\n                max_ending_here=0\n            elif max_so_far < max_ending_here:\n                max_so_far=max_ending_here\n        return max_so_far\n        \nA =[]                  \nn=int(input())\nfor i in range(n):\n    A.append(float(input()))\ns=Solution()\nprint(\"The sum of contiguous sublist with the largest sum is {:.1f}\".format(s.maxSubArray(A)))",
    "Create a python program to find the minimum number of jumps needed to reach end of the array using Dynamic Programming.": "#Correct the errors and add the logic to get the output\ndef minJumps(arr, n):\n    jumps = [0 for i in range(n)]\n    if (n == 0) or (arr[0] == 0):\n        return float('inf')\n    jumps[0] = 0\n    for i in range(1, n):\n        jumps[i] = float('inf')\n        for j in range(i):\n            if (i <= j + arr[j]) and (jumps[j] != float('inf')):\n                jumps[i] = min(jumps[i], jumps[j] + 1)\n                break\n    return jumps[n-1]\narr = []\nn = int(input()) #len(arr)\nfor i in range(n):\n    arr.append(int(input()))\nprint('Minimum number of jumps to reach','end is', minJumps(arr,n))",
    "Print All Paths With Minimum Jumps": "#Correct the errors and add the required logic to get the output.\nfrom queue import Queue\nimport sys\nclass Pair(object):\n    idx = 0\n    psf = \"\"\n    jmps = 0\n    def __init__(self, idx, psf, jmps):\n        self.idx = idx\n        self.psf = psf\n        self.jmps = jmps\ndef minJumps(arr):\n    MAX_VALUE = sys.maxsize\n    dp = [MAX_VALUE for i in range(len(arr))]\n    n = len(dp)\n    dp[n - 1] = 0\n    for i in range(n - 2, -1, -1):\n        steps = arr[i]\n        minimum = MAX_VALUE\n        for j in range(1, steps + 1, 1):\n            if i + j >= n:\n                break\n            if ((dp[i + j] != MAX_VALUE) and\n                (dp[i + j] < minimum)):\n                minimum = dp[i + j]\n        if minimum != MAX_VALUE:\n            dp[i] = minimum + 1\n    return dp\n    \ndef possiblePath(arr, dp):\n \n    queue = Queue(maxsize = 0)\n    p1 = Pair(0, \"0\", dp[0])\n    queue.put(p1)\n \n    while queue.qsize() > 0:\n        tmp = queue.get()\n \n        if tmp.jmps == 0:\n            print(tmp.psf)\n            continue\n \n        for step in range(1, arr[tmp.idx] + 1, 1):\n            if ((tmp.idx + step < len(arr)) and\n               (tmp.jmps - 1 == dp[tmp.idx + step])):\n               \n                # Storing the neighbours\n                # of current index element\n                p2 = Pair(tmp.idx + step, tmp.psf +\n                           \" -> \" + str((tmp.idx + step)),\n                         tmp.jmps - 1)\n                          \n                queue.put(p2)\ndef Solution(arr):\n    dp = minJumps(arr)\n    possiblePath(arr, dp)\n    \nif __name__ == \"__main__\":\n     \n    arr = []#[ 3, 3, 0, 2, 1,2, 4, 2, 0, 0 ]\n    size = int(input())\n    for i in range(size):\n        arr.append(int(input()))\n    Solution(arr)",
    "You are given an integer N. For a given N x N chessboard, find a way to place 'N' queens such that no queen can attack any other queen on the chessboard.": "global N\nN=int(input())\ndef printSolution(board):\n    for i in range(N):\n        for j in range(N):\n            print(board[i][j],end=\" \")\n        print()\n\ndef isSafe(board,row,col):\n    for i in range(col):\n        if board[row][i]==1:\n            return False\n    for i,j in zip(range(row,-1,-1),range(col,-1,-1)):\n        if board[i][j]==1:\n            return False\n    for i,j in zip(range(row,N,1),range(col,-1,-1)):\n        if board[i][j]==1:\n            return False \n    return True\n\ndef solveUtil(board,col):\n    if col>=N:\n        return True\n    for i in range(N):\n        if isSafe(board,i,col):\n            board[i][col]=1\n            if solveUtil(board,col+1)==True:\n                return True\n            board[i][col]=0\n    return False\n\ndef solveNQ():\n    board=[[0,0,0,0,0,0,0,0],\n           [0,0,0,0,0,0,0,0],\n           [0,0,0,0,0,0,0,0],\n           [0,0,0,0,0,0,0,0],\n           [0,0,0,0,0,0,0,0],\n           [0,0,0,0,0,0,0,0],\n           [0,0,0,0,0,0,0,0],\n           [0,0,0,0,0,0,0,0]]\n    if solveUtil(board,0)==False:\n        print(\"Solution does not exist\")\n        return False\n    printSolution(board)\n    return True\nsolveNQ()"
}