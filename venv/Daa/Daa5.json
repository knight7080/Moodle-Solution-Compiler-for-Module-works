{
    "Create a python program for the following problem statement.": "#Correct the Errors and Add Required logic to get the output\n\nclass Solution:\n    def cherryPickup(self, grid):\n        n = len(grid)\n        #############    Add your code here  ###############\n        dp = [[-1] * (n + 1) for _ in range(n + 1)]\n        dp[1][1] = grid[0][0]\n        for m in range(1, (n << 1) - 1):\n            for i in range(min(m, n - 1), max(-1, m - n), -1):\n                for p in range(i, max(-1, m - n), -1):\n                    j, q = m - i, m - p\n                    if grid[i][j] == -1 or grid[p][q] == -1:\n                        dp[i + 1][p + 1] = -1\n                    else:\n                        dp[i + 1][p + 1] = max(dp[i + 1][p + 1], dp[i][p + 1], dp[i + 1][p], dp[i][p])\n                        if dp[i + 1][p + 1] != -1: dp[i + 1][p + 1] += grid[i][j] + (grid[p][q] if i != p else 0)\n        return max(0, dp[-1][-1])\n        n,m=len(grid),len(grid[0])\n        dp = [[[-1 for i in range(m)] for j1 in range(n)] for j2 in range(n)]\n        return f(0,0,m-1,dp)\nobj=Solution()\ngrid=[[0,1,-1],[1,0,-1],[1,1,1]]        \nprint(obj.cherryPickup(grid))",
    "Create a python program for 0/1 knapsack problem using naive recursion method": "def knapSack(W, wt, val, n):\n    ############### Add your code here ##############\n    if n==0 or W==0:\n        return 0\n    if wt[n-1]>W:\n        return knapSack(W, wt, val, n-1)\n    else:\n        return max(val[n-1]+knapSack(W-wt[n-1], wt, val, n-1),knapSack(W, wt, val, n-1))\nx=int(input())\ny=int(input())\nW=int(input())\nval=[]\nwt=[]\nfor i in range(x):\n    val.append(int(input()))\nfor y in range(y):\n    wt.append(int(input()))\nn = len(val)\nprint('The maximum value that can be put in a knapsack of capacity W is: ',knapSack(W, wt, val, n))",
    "For example:": "def knapSack(W, wt, val, n):\n\tif n == 0 or W == 0 :\n\t\treturn 0\n\tif (wt[n-1] > W):\n\t\treturn knapSack(W, wt, val, n-1)\n\telse:\n\t\treturn max(val[n-1] + knapSack(W-wt[n-1], wt, val, n-1), knapSack(W, wt, val, n-1))\nx=int(input())\ny=int(input())\nW=int(input())\nval=[]\nwt=[]\nfor i in range(x):\n    val.append(int(input()))\nfor y in range(y):\n    wt.append(int(input()))\n\nn = len(val)\nprint('The maximum value that can be put in a knapsack of capacity W is: ',knapSack(W, wt, val, n))",
    "Solve Travelling Sales man Problem for the following graph": "from sys import maxsize\nfrom itertools import permutations\nV = 4\ndef travellingSalesmanProblem(graph, s):\n    #Write your code\n    vertices=[]\n    for i in range(V):\n        if i!=s:\n            vertices.append(i)\n    min_path=maxsize\n    next_permutations=permutations(vertices)\n    for i in next_permutations:\n        current_wight=0\n        k=s\n        for j in i:\n            current_wight+=graph[k][j]\n            k=j\n        current_wight+=graph[k][s]\n        min_path=min(min_path,current_wight)\n    return min_path\n    \nif __name__ == \"__main__\":\n    graph = [[0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0]]\n    s=0\n    print(travellingSalesmanProblem(graph, s))\n    ",
    "Given a 2D matrix tsp[][], where each row has the array of distances from that indexed city to all the other cities and -1 denotes that there doesn\u2019t exist a path between those two indexed cities. The task is to print minimum cost in TSP cycle.": "from typing import DefaultDict\nINT_MAX = 2147483647\ndef findMinRoute(tsp):\n    sum = 0\n    counter = 0\n    j = 0\n    i = 0\n    min = INT_MAX\n    visitedRouteList = DefaultDict(int)\n    visitedRouteList[0] = 1\n    route = [0] * len(tsp)\n    while i < len(tsp) and j < len(tsp[i]):\n        #Write your code here\n        #Start here\n        if counter >= len(tsp[i]) - 1:\n            break\n        if j != i and (visitedRouteList[j] == 0):\n            if tsp[i][j] < min:\n                min = tsp[i][j]\n                route[counter] = j + 1\n        j += 1\n        if j == len(tsp[i]):\n            sum += min\n            min = INT_MAX\n            visitedRouteList[route[counter] - 1] = 1\n            j = 0\n            i = route[counter] - 1\n            counter += 1\n    i = route[counter - 1] - 1\n    #End here\n    \n    for j in range(len(tsp)):\n        if (i != j) and tsp[i][j] < min:\n            min = tsp[i][j]\n            route[counter] = j + 1\n    sum += min\n    print(\"Minimum Cost is :\", sum)\n \n # Driver Code\nif __name__ == \"__main__\":\n    tsp = [[-1, 30, 25, 10], \n[15, -1, 20, 40], \n[10, 20, -1, 25], \n[30, 10, 20, -1]] \n    # Function Call\n    findMinRoute(tsp)",
    "Create a python program using brute force method of searching for the given substring in the main string.": "import re\ndef match(str1,str2):\n    ########### Add your code here #######\n    pattern=re.compile(str2)\n    r=pattern.search(str1)\n    while r:\n        print(\"Found at index\",r.start())\n        r=pattern.search(str1,r.start()+1)\nstr1=input()\nstr2=input()\n",
    "Create a python program to find the maximum value in linear search.": "def find_maximum(lst):\n    #############  Add your code here ##############\n    #Start here\n    max=None\n    for i in lst:\n        if max == None or i > max:\n            max = i\n    return max\n    #End here\ntest_scores = []\nn=int(input())\nfor i in range(n):\n    test_scores.append(int(input()))\nprint(\"Maximum value is \",find_maximum(test_scores))",
    "Create a python program to find the maximum score in linear search.": "def find_maximum(lst):\n    #############  Add your code here ##############\n    #Start here\n    max=None\n    for i in lst:\n        if max == None or i > max:\n            max = i\n    return max\n    #End here\ntest_scores = []\nn=int(input())\nfor i in range(n):\n    test_scores.append(int(input()))\nprint(\"Maximum value is \",find_maximum(test_scores))",
    "Write a recursive python function to perform merge sort on the unsorted list of float values.": "def mergesort(li):\n    if len(li)<2:\n        return li\n    result=[]\n    mid=len(li)//2\n    y=mergesort(li[:mid])\n    z=mergesort(li[mid:])\n    i=0\n    j=0\n    while i<len(y) and j<len(z):\n        if y[i]<z[j]:\n            result.append(y[i])\n            i+=1\n        else:\n            result.append(z[j])\n            j+=1\n    result += y[i:]\n    result += z[j:]\n    return result\nli=[]\nn=int(input())\nfor i in range(n):\n    li.append(float(input()))\nprint(mergesort(li))",
    "You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.": "class Solution(object):\n    def cherryPickup(self, grid):\n        dp=[[0 for j in range(len(grid))]for i in range(len(grid))]\n        for i in range(len(grid)):\n            for j in range(len(grid)-1):\n                dp[i][j]=grid[i-1][j-1]\n        res=len(grid)*6\n        ROW_NUM = len(grid)\n        COL_NUM = len(grid[0])\n        return dp[0][COL_NUM - 1]*res\n        \ngrid=[[3,1,1],\n      [2,5,1],\n      [1,5,5],\n      [2,1,1]]\nob=Solution()\nprint(ob.cherryPickup(grid))"
}